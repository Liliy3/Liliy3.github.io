<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>node.js的一些小知识 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="querystring:可以用作通用解析器的模块很多时候我们会从数据库或其他地方得到这种奇怪格式的字符串:name:Sophie;shape:fox;condition:new，一般来说我们会利用字符串切割的方式来讲字符串划分到JavaScript Object。不过querystring也是个不错的现成的工具:

const weirdoString = name:Sophie;shape:fo">
<meta property="og:type" content="article">
<meta property="og:title" content="node.js的一些小知识">
<meta property="og:url" content="http://yoursite.com/2016/07/20/node-js的一些小知识/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="querystring:可以用作通用解析器的模块很多时候我们会从数据库或其他地方得到这种奇怪格式的字符串:name:Sophie;shape:fox;condition:new，一般来说我们会利用字符串切割的方式来讲字符串划分到JavaScript Object。不过querystring也是个不错的现成的工具:

const weirdoString = name:Sophie;shape:fo">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib0vZALXibl3bLyFLgWHnXKvoU1EXKfQqaicvM7vX7UgeSs1vkxwWukNr2zywib04HqU0w2WRNvtZ4rYw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib0vZALXibl3bLyFLgWHnXKvoGkU7l7AVxN27CTJOHslaXtEEHvjjVUS3wiaiaFFK8Of5df4zSLr9jOLg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:updated_time" content="2017-03-10T11:56:33.377Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="node.js的一些小知识">
<meta name="twitter:description" content="querystring:可以用作通用解析器的模块很多时候我们会从数据库或其他地方得到这种奇怪格式的字符串:name:Sophie;shape:fox;condition:new，一般来说我们会利用字符串切割的方式来讲字符串划分到JavaScript Object。不过querystring也是个不错的现成的工具:

const weirdoString = name:Sophie;shape:fo">
<meta name="twitter:image" content="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib0vZALXibl3bLyFLgWHnXKvoU1EXKfQqaicvM7vX7UgeSs1vkxwWukNr2zywib04HqU0w2WRNvtZ4rYw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-node-js的一些小知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/20/node-js的一些小知识/" class="article-date">
  <time datetime="2016-07-20T12:54:48.000Z" itemprop="datePublished">2016-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      node.js的一些小知识
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="querystring-可以用作通用解析器的模块"><a href="#querystring-可以用作通用解析器的模块" class="headerlink" title="querystring:可以用作通用解析器的模块"></a>querystring:可以用作通用解析器的模块</h1><p>很多时候我们会从数据库或其他地方得到这种奇怪格式的字符串:<code>name:Sophie;shape:fox;condition:new</code>，一般来说我们会利用字符串切割的方式来讲字符串划分到JavaScript Object。不过<code>querystring</code>也是个不错的现成的工具:</p>
<blockquote>
<p>const weirdoString = <code>name:Sophie;shape:fox;condition:new</code>;</p>
<p>const result = querystring.parse(weirdoString, <code>;</code>, <code>:</code>);</p>
<p>// result:</p>
<p>// {</p>
<p>//   name: <code>Sophie</code>,</p>
<p>//   shape: <code>fox</code>,</p>
<p>//   condition: <code>new</code>,</p>
<p>// };</p>
</blockquote>
<h1 id="V8-Inspector"><a href="#V8-Inspector" class="headerlink" title="V8 Inspector"></a>V8 Inspector</h1><p>以<code>--inspect</code>参数运行你的Node应用程序，它会反馈你某个URL。将该URL复制到Chrome中并打开，你就可以使用Chrome DevTools来调试你的Node应用程序啦。详细的实验可以参考这篇文章。不过需要注意的是，该参数仍然属于实验性质</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib0vZALXibl3bLyFLgWHnXKvoU1EXKfQqaicvM7vX7UgeSs1vkxwWukNr2zywib04HqU0w2WRNvtZ4rYw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<h1 id="nextTick-与-setImmediate的区别"><a href="#nextTick-与-setImmediate的区别" class="headerlink" title="nextTick 与 setImmediate的区别"></a>nextTick 与 setImmediate的区别</h1><p>这两货的区别可能光从名字上还看不出来，我觉得应该给它们取个别名:</p>
<ul>
<li><code>process.nextTick()</code>应该为<code>process.sendThisToTheStartOfTheQueue()</code></li>
<li><code>setImmediate</code>应该为<code>sendThisToTheEndOfTheQueue()</code></li>
</ul>
<p>再说句不相关的，React中的Props应该为<code>stuffThatShouldStayTheSameIfTheUserRefreshes</code>，而State应该为<code>stuffThatShouldBeForgottenIfTheUserRefreshes</code>。</p>
<h1 id="Server-listen-可以使用Object作为参数"><a href="#Server-listen-可以使用Object作为参数" class="headerlink" title="Server.listen 可以使用Object作为参数"></a>Server.listen 可以使用Object作为参数</h1><p>我更喜欢命名参数的方式调用函数，这样相较于仅按照顺序的无命名参数法会更直观。别忘了Server.listen也可以使用某个Object作为参数:</p>
<blockquote>
<p>require(<code>http</code>)</p>
<p>  .createServer()</p>
<p>  .listen({</p>
<pre><code>port: 8080,

host: `localhost`,
</code></pre><p>  })</p>
<p>  .on(<code>request</code>, (req, res) =&gt; {</p>
<pre><code>res.end(`Hello World!`);
</code></pre><p>  });</p>
</blockquote>
<p>不过这个特性不是表述在http.Server这个API中，而是在其父级net.Server的文档中。</p>
<h1 id="相对地址"><a href="#相对地址" class="headerlink" title="相对地址"></a>相对地址</h1><p>你传入<code>fs</code>模块的距离可以是相对地址，即相对于<code>process.cwd()</code>。估计有些人早就知道了，不过我之前一直以为是只能使用绝对地址:</p>
<blockquote>
<p>const fs = require(<code>fs</code>);</p>
<p>const path = require(<code>path</code>);</p>
<p>// why have I always done this…</p>
<p>fs.readFile(path.join(__dirname, <code>myFile.txt</code>), (err, data) =&gt; {</p>
<p>  // do something</p>
<p>});</p>
<p>// when I could just do this?</p>
<p>fs.readFile(<code>./path/to/myFile.txt</code>, (err, data) =&gt; {</p>
<p>  // do something</p>
<p>});</p>
</blockquote>
<h1 id="Path-Parsing-路径解析"><a href="#Path-Parsing-路径解析" class="headerlink" title="Path Parsing:路径解析"></a>Path Parsing:路径解析</h1><p>之前我一直不知道的某个功能就是从某个文件名中解析出路径，文件名，文件扩展等等:</p>
<blockquote>
<p>myFilePath = <code>/someDir/someFile.json</code>;</p>
<p>path.parse(myFilePath).base === <code>someFile.json</code>; // true</p>
<p>path.parse(myFilePath).name === <code>someFile</code>; // true</p>
<p>path.parse(myFilePath).ext === <code>.json</code>; // true</p>
</blockquote>
<h1 id="Logging-with-colors"><a href="#Logging-with-colors" class="headerlink" title="Logging with colors"></a>Logging with colors</h1><p>别忘了<code>console.dir(obj,{colors:true})</code>能够以不同的色彩打印出键与值，这一点会大大增加日志的可读性。</p>
<h1 id="使用setInterval执行定时任务"><a href="#使用setInterval执行定时任务" class="headerlink" title="使用setInterval执行定时任务"></a>使用setInterval执行定时任务</h1><p>我喜欢使用<code>setInterval</code>来定期执行数据库清理任务，不过默认情况下在存在<code>setInterval</code>的时候NodeJS并不会退出，你可以使用如下的方法让Node沉睡:</p>
<blockquote>
<p>const dailyCleanup = setInterval(() =&gt; {</p>
<p>  cleanup();</p>
<p>}, 1000 <em> 60 </em> 60 * 24);</p>
<p>dailyCleanup.unref();</p>
</blockquote>
<h1 id="Use-Signal-Constants"><a href="#Use-Signal-Constants" class="headerlink" title="Use Signal Constants"></a>Use Signal Constants</h1><p>如果你尝试在NodeJS中杀死某个进程，估计你用过如下语法:</p>
<blockquote>
<p>process.kill(process.pid, <code>SIGTERM</code>);</p>
</blockquote>
<p>这个没啥问题，不过既然第二个参数同时能够使用字符串与整形变量，那么还不如使用全局变量呢:</p>
<blockquote>
<p>process.kill(process.pid, os.constants.signals.SIGTERM);</p>
</blockquote>
<h1 id="IP-Address-Validation"><a href="#IP-Address-Validation" class="headerlink" title="IP Address Validation"></a>IP Address Validation</h1><p>NodeJS中含有内置的IP地址校验工具，这一点可以免得你写额外的正则表达式:</p>
<blockquote>
<p>require(<code>net</code>).isIP(<code>10.0.0.1</code>) 返回 4</p>
<p>require(<code>net</code>).isIP(<code>cats</code>) 返回 0</p>
</blockquote>
<h1 id="os-EOF"><a href="#os-EOF" class="headerlink" title="os.EOF"></a>os.EOF</h1><p>不知道你有没有手写过行结束符，看上去可不漂亮啊。NodeJS内置了<code>os.EOF</code>，其在Windows下是<code>rn</code>，其他地方是<code>n</code>，使用os.EOL能够让你的代码在不同的操作系统上保证一致性:</p>
<blockquote>
<p>const fs = require(<code>fs</code>);</p>
<p>// bad</p>
<p>fs.readFile(<code>./myFile.txt</code>, <code>utf8</code>, (err, data) =&gt; {</p>
<p>  data.split(<code>\r\n</code>).forEach(line =&gt; {</p>
<pre><code>// do something
</code></pre><p>  });</p>
<p>});</p>
<p>// good</p>
<p>const os = require(<code>os</code>);</p>
<p>fs.readFile(<code>./myFile.txt</code>, <code>utf8</code>, (err, data) =&gt; {</p>
<p>  data.split(os.EOL).forEach(line =&gt; {</p>
<pre><code>// do something
</code></pre><p>  });</p>
<p>});</p>
</blockquote>
<h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><p>NodeJS帮我们内置了HTTP状态码及其描述，也就是<code>http.STATUS_CODES</code>，键为状态值，值为描述:<br><img src="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib0vZALXibl3bLyFLgWHnXKvoGkU7l7AVxN27CTJOHslaXtEEHvjjVUS3wiaiaFFK8Of5df4zSLr9jOLg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>你可以按照如下方法使用:</p>
<blockquote>
<p>someResponse.code === 301; // true</p>
<p>require(<code>http</code>).STATUS_CODES[someResponse.code] === <code>Moved Permanently</code>; // true</p>
</blockquote>
<h1 id="避免异常崩溃"><a href="#避免异常崩溃" class="headerlink" title="避免异常崩溃"></a>避免异常崩溃</h1><p>有时候碰到如下这种导致服务端崩溃的情况还是挺无奈的:</p>
<blockquote>
<p>const jsonData = getDataFromSomeApi(); // But oh no, bad data!</p>
<p>const data = JSON.parse(jsonData); // Loud crashing noise.</p>
</blockquote>
<p>我为了避免这种情况，在全局加上了一个:</p>
<blockquote>
<p>process.on(<code>uncaughtException</code>, console.error);</p>
</blockquote>
<p>当然，这种办法绝不是最佳实践，如果是在大型项目中我还是会使用PM2，然后将所有可能崩溃的代码加入到<code>try...catch</code>中。</p>
<h1 id="Just-this-once"><a href="#Just-this-once" class="headerlink" title="Just this once()"></a>Just this once()</h1><p>除了<code>on</code>方法，<code>once</code>方法也适用于所有的EventEmitters，希望我不是最后才知道这个的:</p>
<blockquote>
<p>server.once(<code>request</code>, (req, res) =&gt; res.end(<code>No more from me.</code>));</p>
</blockquote>
<h1 id="Custom-Console"><a href="#Custom-Console" class="headerlink" title="Custom Console"></a>Custom Console</h1><p>你可以使用<code>new console.Console(standardOut,errorOut)</code>，然后设置自定义的输出流。你可以选择创建console将数据输出到文件或者Socket或者第三方中。</p>
<h1 id="DNS-lookup"><a href="#DNS-lookup" class="headerlink" title="DNS lookup"></a>DNS lookup</h1><p>某个年轻人告诉我，Node并不会缓存DNS查询信息，因此你在使用URL之后要等个几毫秒才能获取到数据。不过其实你可以使用<code>dns.lookup()</code>来缓存数据:</p>
<blockquote>
<p>dns.lookup(<code>www.myApi.com</code>, 4, (err, address) =&gt; {</p>
<p>  cacheThisForLater(address);</p>
<p>});</p>
</blockquote>
<h1 id="fs-在不同OS上有一定差异"><a href="#fs-在不同OS上有一定差异" class="headerlink" title="fs 在不同OS上有一定差异"></a>fs 在不同OS上有一定差异</h1><ul>
<li><code>fs.stats()</code>返回的对象中的<code>mode</code>属性在Windows与其他操作系统中存在差异。</li>
<li><code>fs.lchmod()</code>仅在macOS中有效。</li>
<li>仅在Windows中支持调用<code>fs.symlink()</code>时使用<code>type</code>参数。</li>
<li>仅仅在macOS与Windows中调用<code>fs.watch()</code>时传入<code>recursive</code>选项。</li>
<li>在Linux与Windows中<code>fs.watch()</code>的回调可以传入某个文件名</li>
<li>使用<code>fs.open()</code>以及<code>a+</code>属性打开某个目录时仅仅在FreeBSD以及Windows上起作用，在macOS以及Linux上则存在问题。</li>
<li>在Linux下以追加模式打开某个文件时，传入到<code>fs.write()</code>的<code>position</code>参数会被忽略。</li>
</ul>
<h1 id="net-模块差不多比http快上两倍"><a href="#net-模块差不多比http快上两倍" class="headerlink" title="net 模块差不多比http快上两倍"></a>net 模块差不多比http快上两倍</h1><p>笔者在文档中看到一些关于二者性能的讨论，还特地运行了两个服务器来进行真实比较。结果来看<code>http.Server</code>大概每秒可以接入3400个请求，而<code>net.Server</code>可以接入大概5500个请求。</p>
<blockquote>
<p>// This makes two connections, one to a tcp server, one to an http server (both in server.js)</p>
<p>// It fires off a bunch of connections and times the response</p>
<p>// Both send strings.</p>
<p>const net = require(<code>net</code>);</p>
<p>const http = require(<code>http</code>);</p>
<p>function parseIncomingMessage(res) {</p>
<p>  return new Promise((resolve) =&gt; {</p>
<pre><code>let data = ``;



res.on(`data`, (chunk) =&gt; {

  data += chunk;

});



res.on(`end`, () =&gt; resolve(data));
</code></pre><p>  });</p>
<p>}</p>
<p>const testLimit = 5000;</p>
<p>/<em>  ——————  </em>/</p>
<p>/<em>  –  NET client  –  </em>/</p>
<p>/<em>  ——————  </em>/</p>
<p>function testNetClient() {</p>
<p>  const netTest = {</p>
<pre><code>startTime: process.hrtime(),

responseCount: 0,

testCount: 0,

payloadData: {

  type: `millipede`,

  feet: 100,

  test: 0,

},
</code></pre><p>  };</p>
<p>  function handleSocketConnect() {</p>
<pre><code>netTest.payloadData.test++;

netTest.payloadData.feet++;



const payload = JSON.stringify(netTest.payloadData);



this.end(payload, `utf8`);
</code></pre><p>  }</p>
<p>  function handleSocketData() {</p>
<pre><code>netTest.responseCount++;



if (netTest.responseCount === testLimit) {

  const hrDiff = process.hrtime(netTest.startTime);

  const elapsedTime = hrDiff[0] * 1e3 + hrDiff[1] / 1e6;

  const requestsPerSecond = (testLimit / (elapsedTime / 1000)).toLocaleString();



  console.info(`net.Server handled an average of ${requestsPerSecond} requests per second.`);

}
</code></pre><p>  }</p>
<p>  while (netTest.testCount &lt; testLimit) {</p>
<pre><code>netTest.testCount++;

const socket = net.connect(8888, handleSocketConnect);

socket.on(`data`, handleSocketData);
</code></pre><p>  }</p>
<p>}</p>
<p>/<em>  ——————-  </em>/</p>
<p>/<em>  –  HTTP client  –  </em>/</p>
<p>/<em>  ——————-  </em>/</p>
<p>function testHttpClient() {</p>
<p>  const httpTest = {</p>
<pre><code>startTime: process.hrtime(),

responseCount: 0,

testCount: 0,
</code></pre><p>  };</p>
<p>  const payloadData = {</p>
<pre><code>type: `centipede`,

feet: 100,

test: 0,
</code></pre><p>  };</p>
<p>  const options = {</p>
<pre><code>hostname: `localhost`,

port: 8080,

method: `POST`,

headers: {

  &apos;Content-Type&apos;: `application/x-www-form-urlencoded`,

},
</code></pre><p>  };</p>
<p>  function handleResponse(res) {</p>
<pre><code>parseIncomingMessage(res).then(() =&gt; {

  httpTest.responseCount++;



  if (httpTest.responseCount === testLimit) {

    const hrDiff = process.hrtime(httpTest.startTime);

    const elapsedTime = hrDiff[0] * 1e3 + hrDiff[1] / 1e6;

    const requestsPerSecond = (testLimit / (elapsedTime / 1000)).toLocaleString();



    console.info(`http.Server handled an average of ${requestsPerSecond} requests per second.`);

  }

});
</code></pre><p>  }</p>
<p>  while (httpTest.testCount &lt; testLimit) {</p>
<pre><code>httpTest.testCount++;

payloadData.test = httpTest.testCount;

payloadData.feet++;



const payload = JSON.stringify(payloadData);



options[`Content-Length`] = Buffer.byteLength(payload);



const req = http.request(options, handleResponse);

req.end(payload);
</code></pre><p>  }</p>
<p>}</p>
<p>/<em>  –  Start tests  –  </em>/</p>
<p>// flip these occasionally to ensure there’s no bias based on order</p>
<p>setTimeout(() =&gt; {</p>
<p>  console.info(<code>Starting testNetClient()</code>);</p>
<p>  testNetClient();</p>
<p>}, 50);</p>
<p>setTimeout(() =&gt; {</p>
<p>  console.info(<code>Starting testHttpClient()</code>);</p>
<p>  testHttpClient();</p>
<p>}, 2000);</p>
<p>// This sets up two servers. A TCP and an HTTP one.</p>
<p>// For each response, it parses the received string as JSON, converts that object and returns a string</p>
<p>const net = require(<code>net</code>);</p>
<p>const http = require(<code>http</code>);</p>
<p>function renderAnimalString(jsonString) {</p>
<p>  const data = JSON.parse(jsonString);</p>
<p>  return <code>${data.test}: your are a ${data.type} and you have ${data.feet} feet.</code>;</p>
<p>}</p>
<p>/<em>  ——————  </em>/</p>
<p>/<em>  –  NET server  –  </em>/</p>
<p>/<em>  ——————  </em>/</p>
<p>net</p>
<p>  .createServer((socket) =&gt; {</p>
<pre><code>socket.on(`data`, (jsonString) =&gt; {

  socket.end(renderAnimalString(jsonString));

});
</code></pre><p>  })</p>
<p>  .listen(8888);</p>
<p>/<em>  ——————-  </em>/</p>
<p>/<em>  –  HTTP server  –  </em>/</p>
<p>/<em>  ——————-  </em>/</p>
<p>function parseIncomingMessage(res) {</p>
<p>  return new Promise((resolve) =&gt; {</p>
<pre><code>let data = ``;



res.on(`data`, (chunk) =&gt; {

  data += chunk;

});



res.on(`end`, () =&gt; resolve(data));
</code></pre><p>  });</p>
<p>}</p>
<p>http</p>
<p>  .createServer()</p>
<p>  .listen(8080)</p>
<p>  .on(<code>request</code>, (req, res) =&gt; {</p>
<pre><code>parseIncomingMessage(req).then((jsonString) =&gt; {

  res.end(renderAnimalString(jsonString));

});
</code></pre><p>  });</p>
</blockquote>
<h1 id="REPL-tricks"><a href="#REPL-tricks" class="headerlink" title="REPL tricks"></a>REPL tricks</h1><ul>
<li>如果你是在REPL模式下，就是直接输入node然后进入交互状态的模式。你可以直接输入<code>.load someFile.js</code>然后可以载入包含自定义常量的文件。</li>
<li>可以通过设置<code>NODE_REPL_HISTORY=&quot;&quot;</code>来避免将日志写入到文件中。</li>
<li><code>_</code>用来记录最后一个计算值。</li>
<li>在REPL启动之后，所有的模块都已经直接加载成功。可以使用<code>os.arch()</code>而不是<code>require(</code>os<code>).arch()</code>来使用。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/20/node-js的一些小知识/" data-id="cj057dqk70001gctxewq5fjky" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/10/MVVM和Vue-js/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          MVVM和Vue.js
        
      </div>
    </a>
  
  
    <a href="/2016/05/18/原生JS/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">原生JS</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/10/MVVM和Vue-js/">MVVM和Vue.js</a>
          </li>
        
          <li>
            <a href="/2016/07/20/node-js的一些小知识/">node.js的一些小知识</a>
          </li>
        
          <li>
            <a href="/2016/05/18/原生JS/">原生JS</a>
          </li>
        
          <li>
            <a href="/2016/05/10/前端跨域请求原理及实践/">前端跨域请求原理及实践</a>
          </li>
        
          <li>
            <a href="/2016/03/18/详细图解作用域链与闭包/">详细图解作用域链与闭包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>