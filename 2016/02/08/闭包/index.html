<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>闭包 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是闭包？
简言之，闭包是由函数引用其周边状态（词法环境）绑在一起形成的（封装）组合结构。在 JavaScript 中，闭包在每个函数被创建时形成。
这是基本原理，但为什么我们关心这些？实际上，由于闭包与它的词法环境绑在一起，因此闭包让我们能够从一个函数内部访问其外部函数的作用域。
要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函">
<meta property="og:type" content="article">
<meta property="og:title" content="闭包">
<meta property="og:url" content="http://yoursite.com/2016/02/08/闭包/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="什么是闭包？
简言之，闭包是由函数引用其周边状态（词法环境）绑在一起形成的（封装）组合结构。在 JavaScript 中，闭包在每个函数被创建时形成。
这是基本原理，但为什么我们关心这些？实际上，由于闭包与它的词法环境绑在一起，因此闭包让我们能够从一个函数内部访问其外部函数的作用域。
要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函">
<meta property="og:updated_time" content="2017-03-10T11:52:16.469Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闭包">
<meta name="twitter:description" content="什么是闭包？
简言之，闭包是由函数引用其周边状态（词法环境）绑在一起形成的（封装）组合结构。在 JavaScript 中，闭包在每个函数被创建时形成。
这是基本原理，但为什么我们关心这些？实际上，由于闭包与它的词法环境绑在一起，因此闭包让我们能够从一个函数内部访问其外部函数的作用域。
要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/08/闭包/" class="article-date">
  <time datetime="2016-02-08T11:45:20.000Z" itemprop="datePublished">2016-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      闭包
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>什么是闭包？</strong></p>
<p>简言之，闭包是由函数引用其周边状态（词法环境）绑在一起形成的（封装）组合结构。在 JavaScript 中，闭包在每个函数被创建时形成。</p>
<p>这是基本原理，但为什么我们关心这些？实际上，由于闭包与它的词法环境绑在一起，因此闭包让我们能够从一个函数内部访问其外部函数的作用域。</p>
<p>要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。</p>
<p>内部函数将能够访问到外部函数作用域中的变量，即使外部函数已经执行完毕。</p>
<p><strong>闭包使用的例子</strong></p>
<p>闭包的用途之一是实现对象的私有数据。数据私有是让我们能够面向接口编程而不是面向实现编程的基础。而面向接口编程是一个重要的概念，有助于我们创建更加健壮的软件，因为实现细节比接口约定相对来说更加容易被改变。</p>
<blockquote>
<p>“面向接口编程，别面向实现编程。” 设计模式：可复用面向对象软件的要素</p>
</blockquote>
<p>在 JavaScript 中，闭包是用来实现数据私有的原生机制。当你使用闭包来实现数据私有时，被封装的变量只能在闭包容器函数作用域中使用。你无法绕过对象被授权的方法在外部访问这些数据。在 JavaScript 中，任何定义在闭包作用域下的公开方法才可以访问这些数据。例如：</p>
<blockquote>
<p>const getSecret = (secret) =&gt; {</p>
<p>  return {</p>
<pre><code>get: () =&gt; secret
</code></pre><p>  };</p>
<p>};</p>
<p>test(‘Closure for object privacy.’, assert =&gt; {</p>
<p>  const msg = ‘.get() should have access to the closure.’;</p>
<p>  const expected = 1;</p>
<p>  const obj = getSecret(1);</p>
<p>  const actual = obj.get();</p>
<p>  try {</p>
<pre><code>assert.ok(secret, &apos;This throws an error.&apos;);
</code></pre><p>  } catch (e) {</p>
<pre><code>assert.ok(true, `The secret var is only available

  to privileged methods.`);
</code></pre><p>  }</p>
<p>  assert.equal(actual, expected, msg);</p>
<p>  assert.end();</p>
<p>});</p>
</blockquote>
<p>在上面的例子里，get() 方法定义在 getSecret() 作用域下，这让它可以访问任何 getSecret() 中的变量，于是它就是一个被授权的方法。在这个例子里，它可以访问参数 secret。</p>
<p>对象不是唯一的产生私有数据的方式。闭包还可以被用来创建有状态的函数，这些函数的执行过程可能由它们自身的内部状态所决定。例如：</p>
<blockquote>
<p>const secret = (msg) =&gt; () =&gt; msg;</p>
<p>// Secret - creates closures with secret messages.</p>
<p>// <a href="https://gist.github.com/ericelliott/f6a87bc41de31562d0f9" target="_blank" rel="external">https://gist.github.com/ericelliott/f6a87bc41de31562d0f9</a></p>
<p>// <a href="https://jsbin.com/hitusu/edit?html,js,output" target="_blank" rel="external">https://jsbin.com/hitusu/edit?html,js,output</a></p>
<p>// secret(msg: String) =&gt; getSecret() =&gt; msg: String</p>
<p>const secret = (msg) =&gt; () =&gt; msg;</p>
<p>test(‘secret’, assert =&gt; {</p>
<p>  const msg = ‘secret() should return a function that returns the passed secret.’;</p>
<p>  const theSecret = ‘Closures are easy.’;</p>
<p>  const mySecret = secret(theSecret);</p>
<p>  const actual = mySecret();</p>
<p>  const expected = theSecret;</p>
<p>  assert.equal(actual, expected, msg);</p>
<p>  assert.end();</p>
<p>});</p>
</blockquote>
<p>在函数式编程中，闭包经常用于偏函数应用和柯里化。为了说明这个，我们先定义一些概念：</p>
<p>函数应用：一个过程，指将参数传给一个函数，并获得它的返回值。</p>
<p>偏函数应用：一个过程，它传给某个函数其中一部分参数，然后返回一个新的函数，该函数等待接受后续参数。换句话说，偏函数应用是一个函数，它接受另一个函数为参数，这个作为参数的函数本身接受多个参数，它返回一个函数，这个函数与它的参数函数相比，接受更少的参数。偏函数应用提前赋予一部分参数，而返回的函数则等待调用时传入剩余的参数。</p>
<p>偏函数应用通过闭包作用域来提前赋予参数。你可以实现一个通用的函数来赋予指定的函数部分参数，它看起来如下：</p>
<blockquote>
<p>partialApply(targetFunction: Function, …fixedArgs: Any[]) =&gt;</p>
<p>  functionWithFewerParams(…remainingArgs: Any[])</p>
</blockquote>
<p>如果你要更进一步理解上面的形式，你可以看这里（<a href="https://github.com/ericelliott/rtype#reading-function-signatures）。" target="_blank" rel="external">https://github.com/ericelliott/rtype#reading-function-signatures）。</a></p>
<p>partialApply 接受一个多参数的函数，以及一串我们想要提前赋给这个函数的参数，它返回一个新的函数，这个函数将接受剩余的参数。</p>
<p>下面给一个例子来说明，假设你有一个函数，求两个数的和：</p>
<blockquote>
<p>const add = (a, b) =&gt; a + b;</p>
</blockquote>
<p>现在你想要得到一个函数，它能够对任何传给它的参数都加 10，我们可以将它命名为add10()。add10(5) 的结果应该是 15。我们的 partialApply() 函数可以做到这个：</p>
<blockquote>
<p>const add10 = partialApply(add, 10);</p>
<p>add10(5);</p>
</blockquote>
<p>在这个例子里，参数 10 通过闭包作用域被提前赋予 add()，从而让我们获得 add10()。</p>
<p>现在让我们看一下如何实现 partialApply()：</p>
<blockquote>
<p>// Generic Partial Application Function</p>
<p>// <a href="https://jsbin.com/biyupu/edit?html,js,output" target="_blank" rel="external">https://jsbin.com/biyupu/edit?html,js,output</a></p>
<p>// <a href="https://gist.github.com/ericelliott/f0a8fd662111ea2f569e" target="_blank" rel="external">https://gist.github.com/ericelliott/f0a8fd662111ea2f569e</a></p>
<p>// partialApply(targetFunction: Function, …fixedArgs: Any[]) =&gt;</p>
<p>//   functionWithFewerParams(…remainingArgs: Any[])</p>
<p>const partialApply = (fn, …fixedArgs) =&gt; {</p>
<p>  return function (…remainingArgs) {</p>
<pre><code>return fn.apply(this, fixedArgs.concat(remainingArgs));
</code></pre><p>  };</p>
<p>};</p>
<p>test(‘add10’, assert =&gt; {</p>
<p>  const msg = ‘partialApply() should partially apply functions’</p>
<p>  const add = (a, b) =&gt; a + b;</p>
<p>  const add10 = partialApply(add, 10);</p>
<p>  const actual = add10(5);</p>
<p>  const expected = 15;</p>
<p>  assert.equal(actual, expected, msg);</p>
<p>});</p>
</blockquote>
<p>如你所见，它只是简单地返回一个函数，这个函数通过闭包访问了传给 partialApply() 函数的fixedArgs 参数。</p>
<p><strong>说了半天，究竟什么是闭包呢？</strong></p>
<ul>
<li>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。</li>
<li>闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。</li>
<li>当在一个函数内定义另外一个函数就会产生闭包。</li>
</ul>
<p><strong>为了便于理解，我们可以简单的将闭包理解为：</strong></p>
<ul>
<li>闭包：是指有权访问另外一个函数作用域中的变量的函数。</li>
</ul>
<p><strong>JavaScript中的作用域</strong></p>
<p>JavaScript中是没有块级作用域的。不过关于块级作用域我们在这里不做深入探究，笔者在JavaScript的作用域和块级作用域概念理解中有对块级作用域较为详细的解释，不懂的读者可以去看看。</p>
<blockquote>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<p>var n=999;</p>
<p>function f1(){</p>
<pre><code>alert(n);
</code></pre><p>}</p>
<p>f1(); // 999</p>
</blockquote>
<p>如上函数，f1可调用全局变量n</p>
<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<blockquote>
<p>function f1(){</p>
<pre><code>var n=999;
</code></pre><p>}</p>
<p>alert(n); // error</p>
</blockquote>
<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量。</p>
<blockquote>
<p>function f1(){</p>
<pre><code>n=999;
</code></pre><p>}</p>
<p>f1();</p>
<p>alert(n); // 999</p>
</blockquote>
<p><strong>闭包</strong></p>
<p>1.理解闭包</p>
<p>我们已经理解了什么是作用域，什么是块级作用域，那又该如何去访问函数内部的变量呢？</p>
<p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<blockquote>
<p>function f1(){</p>
<p>var n=999;</p>
<p>function f2(){</p>
<pre><code>alert(n);
</code></pre><p>}</p>
<pre><code>return f2;
</code></pre><p>}</p>
<p>var result=f1();</p>
<p>result();// 弹出999</p>
</blockquote>
<p>上面函数中的f2函数就是闭包，就是通过建立函数来访问函数内部的局部变量。</p>
<p>2.闭包的用途</p>
<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<blockquote>
<p>function f1(){</p>
<pre><code>var n=999;

nAdd=function(){n+=1}

function f2(){

alert(n);

}

return f2;
</code></pre><p>}</p>
<p>var result=f1();</p>
<p>result(); // 999</p>
<p>nAdd();</p>
<p>result(); // 1000</p>
</blockquote>
<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<p>3.闭包的注意点</p>
<p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<p>4.经典闭包小案例</p>
<p>如果你能理解下面全部的案例，那你的闭包就算是真正掌握了。</p>
<blockquote>
<p>var name = “The Window”;</p>
<p>var object = {</p>
<p>name : “My Object”,</p>
<p>getNameFunc : function(){</p>
<pre><code>return function(){

    return this.name;

    };

}
</code></pre><p>};　　alert(object.getNameFunc()());//The Window</p>
<p>var name = “The Window”;</p>
<p>var object = {</p>
<p>name : “My Object”,</p>
<p>getNameFunc : function(){</p>
<pre><code>var that = this;

return function(){

    return that.name;

    };

}
</code></pre><p>  };</p>
<p>  alert(object.getNameFunc()());//My Object</p>
<p>function fun(n,o) {</p>
<p>  console.log(o)</p>
<p>  return {</p>
<pre><code>fun:function(m){

  return fun(m,n);

}
</code></pre><p>  };</p>
<p>}</p>
<p>var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?</p>
<p>var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?</p>
<p>var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?</p>
</blockquote>
<p>//问:三行a,b,c的输出分别是什么？</p>
<p>这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。</p>
<p>//答案：</p>
<p>//a: undefined,0,0,0</p>
<p>//b: undefined,0,1,2</p>
<p>//c: undefined,0,1,1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/02/08/闭包/" data-id="cj057dqkj0005gctxvcda8dot" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/18/详细图解作用域链与闭包/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          详细图解作用域链与闭包
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/10/MVVM和Vue-js/">MVVM和Vue.js</a>
          </li>
        
          <li>
            <a href="/2016/07/20/node-js的一些小知识/">node.js的一些小知识</a>
          </li>
        
          <li>
            <a href="/2016/05/18/原生JS/">原生JS</a>
          </li>
        
          <li>
            <a href="/2016/05/10/前端跨域请求原理及实践/">前端跨域请求原理及实践</a>
          </li>
        
          <li>
            <a href="/2016/03/18/详细图解作用域链与闭包/">详细图解作用域链与闭包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>