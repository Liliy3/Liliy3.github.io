<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>原生JS | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="数据类型基本类型值包括： undefined，null，Boolean，Number和String，这些类型分别在内存中占有固定的大小空间，它们的值保存在栈空间，我们通过按值来访问的。引用类型包括：对象、数组、函数等。对于引用类型的值，则必须在堆内存中为这个值分配空间。由于引用类型值的大小不固定（对象有很多属性和方法，而且还可以动态的添加属性和方法），因此不能把他们保存到栈内存中。但内存地址大小是">
<meta property="og:type" content="article">
<meta property="og:title" content="原生JS">
<meta property="og:url" content="http://yoursite.com/2016/05/18/原生JS/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据类型基本类型值包括： undefined，null，Boolean，Number和String，这些类型分别在内存中占有固定的大小空间，它们的值保存在栈空间，我们通过按值来访问的。引用类型包括：对象、数组、函数等。对于引用类型的值，则必须在堆内存中为这个值分配空间。由于引用类型值的大小不固定（对象有很多属性和方法，而且还可以动态的添加属性和方法），因此不能把他们保存到栈内存中。但内存地址大小是">
<meta property="og:image" content="http://img.blog.csdn.net/20160809100356773">
<meta property="og:updated_time" content="2017-03-10T13:50:05.538Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="原生JS">
<meta name="twitter:description" content="数据类型基本类型值包括： undefined，null，Boolean，Number和String，这些类型分别在内存中占有固定的大小空间，它们的值保存在栈空间，我们通过按值来访问的。引用类型包括：对象、数组、函数等。对于引用类型的值，则必须在堆内存中为这个值分配空间。由于引用类型值的大小不固定（对象有很多属性和方法，而且还可以动态的添加属性和方法），因此不能把他们保存到栈内存中。但内存地址大小是">
<meta name="twitter:image" content="http://img.blog.csdn.net/20160809100356773">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-原生JS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/18/原生JS/" class="article-date">
  <time datetime="2016-05-18T14:04:59.000Z" itemprop="datePublished">2016-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      原生JS
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p><strong>基本类型值包括：</strong> undefined，null，Boolean，Number和String，这些类型分别在内存中<strong>占有固定的大小空间</strong>，它们的值保存在<strong>栈空间</strong>，我们通过<strong>按值</strong>来访问的。<br><strong>引用类型包括：</strong>对象、数组、函数等。<br><strong>对于引用类型的值</strong>，则必须在<strong>堆内存</strong>中为这个值分配空间。由于引用类型值的<strong>大小不固定</strong>（对象有很多属性和方法，而且还可以动态的添加属性和方法），因此不能把他们保存到栈内存中。但<strong>内存地址大小是固定的</strong>，因此可以<strong>将内存地址保存在栈内存中</strong>。</p>
<p><strong>简而言之：</strong>栈内存中存放的是基本数据类型值，堆内存中存放的是引用类型值，引用类型值在内存中的地址存放在栈中，也就是我们常说的对象对象引用(指针)。<br><img src="http://img.blog.csdn.net/20160809100356773" alt="这里写图片描述"></p>
<h3 id="变量复制"><a href="#变量复制" class="headerlink" title="变量复制"></a><strong>变量复制</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">var a = 5;</div><div class="line">var b = a;</div><div class="line">console.log(a+&quot;---&quot;+b);//5---5</div><div class="line">b = 6;//这里重新给b赋值，a值并没有改变</div><div class="line">console.log(a+&quot;---&quot;+b);//5---6</div><div class="line"></div><div class="line">var obj = &#123;name:&quot;lisi&quot;&#125;;</div><div class="line">var obj2 = obj;//这里是引用赋值，obj和obj2指向同一个对象</div><div class="line">console.log(obj.name + &quot;---&quot; + obj2.name);//lisi---lisi</div><div class="line">obj2.name = &quot;wangwu&quot;;</div><div class="line">console.log(obj.name + &quot;---&quot; + obj2.name);//wangwu---wangwu</div><div class="line">&lt;/script&gt;1234567891011121312345678910111213</div></pre></td></tr></table></figure>
<p>从上面例子可以看出：在变量复制方面，基本类型和引用类型也有所不同，基本类型复制的是<strong>值本身</strong>，而引用类型复制的是内存地址。</p>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><h3 id="this-的工作原理-5种情况"><a href="#this-的工作原理-5种情况" class="headerlink" title="this 的工作原理(5种情况)"></a><strong>this 的工作原理(5种情况)</strong></h3><h4 id="全局作用域内"><a href="#全局作用域内" class="headerlink" title="全局作用域内"></a><strong>全局作用域内</strong></h4><p>当在全部作用域内使用 this时，它将会指向全局对象，即window对象</p>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a><strong>函数调用</strong></h4><p>挡在全局作用域内调用函数时，this 也会指向全局对象。</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a><strong>方法调用</strong></h4><p>this 指向调用该方法的对象。</p>
<h4 id="调用构造函数"><a href="#调用构造函数" class="headerlink" title="调用构造函数"></a><strong>调用构造函数</strong></h4><p>在构造函数内部，this 指向新创建的对象。</p>
<h4 id="显式的设置this指向"><a href="#显式的设置this指向" class="headerlink" title="显式的设置this指向"></a><strong>显式的设置this指向</strong></h4><p>当使用call 或者 apply 方法时，函数内的 this 将会被显式设置为函数调用的第一个参数。<br><strong>更详细用法请见之前的博客：</strong><a href="http://blog.csdn.net/liujie19901217/article/details/51297782" target="_blank" rel="external">传送门</a></p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><strong>匿名函数</strong></h3><p>在<a href="http://lib.csdn.net/base/javascript" target="_blank" rel="external">JavaScript</a>里<strong>任何匿名函数都是属于window对象</strong>。在定义匿名函数时候它会返回自己的内存地址，如果此时有个变量接收了这个内存地址，那么匿名函数就能在程序里被使用了(可以通过在这个变量后面加一对圆括号来调用这个匿名函数)，因为匿名函数也是在全局执行环境构造时候定义和赋值，所以匿名函数的this指向也是window对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">(function()&#123;</div><div class="line">    console.log(this == window);//true</div><div class="line">&#125;)();</div><div class="line">&lt;/script&gt;1234512345</div></pre></td></tr></table></figure>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><strong>参数传递</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">     function test(num)&#123;//按值传递</div><div class="line">         num+=5;</div><div class="line">         console.log(num);</div><div class="line">         return num;</div><div class="line">     &#125;</div><div class="line">     var num = 5;</div><div class="line">     var result = test(num);</div><div class="line">     console.log(result);// 10 如果是按引用传递，那么函数里的num会成为类似全局变量，把外面的num覆盖掉</div><div class="line">     console.log(num);// 5 也就是说，最后应该输出20（这里输出10）</div><div class="line">&lt;/script&gt;12345678910111234567891011</div></pre></td></tr></table></figure>
<p>js中不存在引用传递，如果存在引用传递的话，那么函数内的变量将是全局变量，在外部也可以访问，但这明显是不可能的。<br><strong>再看一个例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">function setName(obj)&#123;//obj = person</div><div class="line">    obj.name = &quot;lisi&quot;;</div><div class="line">    obj = new Object();</div><div class="line">    obj.name = &quot;wangwu&quot;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);</div><div class="line">console.log(obj.name);//Uncaught ReferenceError: obj is not defined</div><div class="line">&lt;/script&gt;12345678910111234567891011</div></pre></td></tr></table></figure>
<p>在将person传递给obj后，其name属性就被设置成了”lisi”。又将obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。<br>如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为”wangwu”的新对象，但事实上并没有，其name属性依然是”lisi”。<br><strong>这就说明：</strong>即使在函数内部修改了参数的值，但原始的引用仍然保持不变。实际上，当在函数内重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p>
<h3 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a><strong>执行环境及作用域</strong></h3><h4 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a><strong>执行环境</strong></h4><p><strong>执行环境</strong>定义了变量或函数有权访问其他数据，可以分为全局执行环境和局部执行环境。<br>全局执行环境是最外层的执行环境，在浏览器中，全局执行环境是window对象，因此，所有的全局变量的函数都是作为window的属性和方法创建的。<br><strong>注意：</strong>对于局部执行环境，其内部的代码执行完毕后，该环境将被销毁，保存其中的变量和函数也随之销毁，如果是全局执行环境，需所有程序执行完毕或网页完毕后才会销毁。</p>
<h4 id="需要注意的小细节"><a href="#需要注意的小细节" class="headerlink" title="需要注意的小细节"></a><strong>需要注意的小细节</strong></h4><h5 id="去掉var的局部变量"><a href="#去掉var的局部变量" class="headerlink" title="去掉var的局部变量"></a><strong>去掉var的局部变量</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">      var name = &quot;wangwu&quot;;</div><div class="line">      function setName()&#123;</div><div class="line">          name = &quot;lisi&quot;;//去掉var变成了全局变量，会覆盖全局中的name</div><div class="line">      &#125;</div><div class="line">      setName();</div><div class="line">      console.log(name);//lisi</div><div class="line">&lt;/script&gt;1234567812345678</div></pre></td></tr></table></figure>
<h5 id="形参也是局部变量"><a href="#形参也是局部变量" class="headerlink" title="形参也是局部变量"></a><strong>形参也是局部变量</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">      var name = &quot;wangwu&quot;;</div><div class="line">      function setName(name)&#123;//形参也是局部变量</div><div class="line">          console.log(name);</div><div class="line">      &#125;</div><div class="line">      setName(&quot;￼lisi&quot;);//lisi</div><div class="line">      console.log(name);//wangwu</div><div class="line">&lt;/script&gt;1234567812345678</div></pre></td></tr></table></figure>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h4><p>当代码在一个环境中执行的时候，就会形成作用域链，它的作用是保证对执行环境中有访问权限的变量和函数进行<strong>有序访问</strong>（内部深层环境可以访问外层环境，反之不成立），作用域链的前端，就是执行环境的变量对象。<br><strong>详见之前博客：</strong><a href="http://blog.csdn.net/liujie19901217/article/details/50709336" target="_blank" rel="external">传送门</a></p>
<h3 id="内存泄漏常见情况"><a href="#内存泄漏常见情况" class="headerlink" title="内存泄漏常见情况"></a><strong>内存泄漏常见情况</strong></h3><p>javascript具有自动垃圾回收机制，一旦数据不再使用，可以将其设为”null”来释放引用。</p>
<h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a><strong>循环引用</strong></h4><p>分为两种情况：不同对象之间相互引用和<br><strong>一个经典的例子：</strong>一个DOM对象被一个Javascript对象引用，与此同时又引用同一个或其它的Javascript对象，这个DOM对象可能会引发内存泄露。这个DOM对象的引用<strong>将不会在脚本停止的时候被垃圾回收器回收。</strong>要想破坏循环引用，引用DOM元素的对象或DOM对象的引用需要被赋值为null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">var oBox = document.getElementById(&quot;box&quot;);</div><div class="line">var obj = &#123;&#125;;</div><div class="line">oBox.name = obj;</div><div class="line">obj.age = oBox;//这样就发生了循环引用</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;1234567812345678</div></pre></td></tr></table></figure>
<h4 id="闭包-常见"><a href="#闭包-常见" class="headerlink" title="闭包(常见)"></a><strong>闭包(常见)</strong></h4><p>通过闭包引用其包含函数的局部变量，当闭包结束后该局部变量无法被垃圾回收机制回收，造成内存泄漏。</p>
<h4 id="DOM泄漏"><a href="#DOM泄漏" class="headerlink" title="DOM泄漏"></a><strong>DOM泄漏</strong></h4><p>当原有的DOM被移除时，子结点引用没有被移除则无法回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var select = document.querySelector;</div><div class="line">var treeRef = select(&apos;#tree&apos;);</div><div class="line">//在COM树中leafRef是treeFre的一个子结点</div><div class="line">var leafRef = select(&apos;#leaf&apos;); </div><div class="line">var body = select(&apos;body&apos;);</div><div class="line">body.removeChild(treeRef);</div><div class="line">//#tree不能被回收入，因为treeRef还在</div><div class="line">//解决方法:</div><div class="line">treeRef = null;</div><div class="line">//tree还不能被回收，因为叶子结果leafRef还在</div><div class="line">leafRef = null;</div><div class="line">//现在#tree可以被释放了。123456789101112123456789101112</div></pre></td></tr></table></figure>
<h4 id="定时器泄漏"><a href="#定时器泄漏" class="headerlink" title="定时器泄漏"></a><strong>定时器泄漏</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; 1000; i++) &#123;</div><div class="line">  var obj = &#123;</div><div class="line">    fn: function() &#123;</div><div class="line">      var that = this;</div><div class="line">      var val = setTimeout(function() &#123;</div><div class="line">        that.fn();</div><div class="line">      &#125;, 500);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  obj.fn();</div><div class="line">  //虽然你想回收但是timer还在</div><div class="line">  obj = null;</div><div class="line">&#125;1234567891011121312345678910111213</div></pre></td></tr></table></figure>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a><strong>垃圾回收</strong></h3><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a><strong>标记清除</strong></h4><p>js中最常用的垃圾回收方式就是标记清除。垃圾收集器在运行的时候回给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，消除那些带标记的值并回收它们所占用的内存空间。<br>例如:在函数中声明一个变量，就将这个变量标记为”进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为”离开环境”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line"> var x = 10 ; //被标记 ，进入环境 </div><div class="line"> var y = 20 ; //被标记 ，进入环境</div><div class="line">&#125;</div><div class="line">test(); //执行完毕后 x、y又被标离开环境，被回收。1234512345</div></pre></td></tr></table></figure>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a><strong>引用计数</strong></h4><p>引用计数就是：跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就<strong>会释放那些引用次数为0的值所占用的内存</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line"> var x = &#123;&#125; ; //x的引用次数为0 </div><div class="line"> var y = x ; //x的引用次数加1，为1 </div><div class="line"> var z =x; //x的引用次数再加1，为2</div><div class="line"> var y =&#123;&#125;; //x的引用次数减1，为1</div><div class="line">&#125;123456123456</div></pre></td></tr></table></figure>
<h5 id="引用计数策略的问题-循环引用"><a href="#引用计数策略的问题-循环引用" class="headerlink" title="引用计数策略的问题(循环引用)"></a><strong>引用计数策略的问题(循环引用)</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function test() &#123;</div><div class="line"> var a = &#123;&#125;;</div><div class="line"> var b = &#123;&#125;;</div><div class="line"> a.name = b;</div><div class="line"> b.name = a;</div><div class="line">&#125;</div><div class="line">test();12345671234567</div></pre></td></tr></table></figure>
<p>以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄露。在IE7与IE8上，内存直线上升。<br>我们知道，IE中<strong>有一部分对象</strong>并不是原生js对象。例如，其BOM和DOM中的对象就是使用C++以<strong>COM对象</strong>的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，<strong>只要在IE中涉及COM对象，就会存在循环引用的问题</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var element = document.getElementById(&quot;some_element&quot;);</div><div class="line">var myObject = new Object();</div><div class="line">myObject.element = element;</div><div class="line">element.someObject = myObject;//产生了循环引用1234</div><div class="line">1234</div></pre></td></tr></table></figure>
<p>这个例子在一个DOM元素（element)与一个原生js对象（myObject)之间创建了<strong>循环引用</strong>。其中，变量myObject有一个名为element的属性指向element对象；而变量element也有一个someObject属性指向myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myObject.element = null;</div><div class="line">element.someObject = null;1212</div></pre></td></tr></table></figure>
<p>为了避免类似这样的循环引用问题，最好在不使用它们的时候手工断开原生js对象与DOM元素之间的连接。将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。<br><strong>注意：</strong>为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的js对象。这样，就避免了两种垃圾收集<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="external">算法</a>并存导致的问题，也消除了常见的内存泄漏现象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/18/原生JS/" data-id="cj057dqka0002gctx4kloh6yw" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/20/node-js的一些小知识/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          node.js的一些小知识
        
      </div>
    </a>
  
  
    <a href="/2016/05/10/前端跨域请求原理及实践/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">前端跨域请求原理及实践</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/10/MVVM和Vue-js/">MVVM和Vue.js</a>
          </li>
        
          <li>
            <a href="/2016/07/20/node-js的一些小知识/">node.js的一些小知识</a>
          </li>
        
          <li>
            <a href="/2016/05/18/原生JS/">原生JS</a>
          </li>
        
          <li>
            <a href="/2016/05/10/前端跨域请求原理及实践/">前端跨域请求原理及实践</a>
          </li>
        
          <li>
            <a href="/2016/03/18/详细图解作用域链与闭包/">详细图解作用域链与闭包</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>