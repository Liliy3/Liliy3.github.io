[{"title":"理解javascript原型","date":"2017-04-20T12:32:10.000Z","path":"2017/04/20/理解javascript原型/","text":"​ Javascript原型总会给人产生一些困惑，无论是经验丰富的专家，还是作者自己也时常表现出对这个概念某些有限的理解，我认为这样的困惑在我们一开始接触原型时就已经产生了，它们常常和new、constructor相关，特别是函数(function)的原型(prototype)属性(property)。事实上，原型是一种非常简单的概念。为了更好的理解它，我们应该首先记住这个原则，那就是忘记我们已经学到的关于构造原型(construtor prototypes)的认识。 什么是原型？ 原型是一个对象，其他对象可以通过它实现属性继承。 任何一个对象都可以成为原型么？ 是 哪些对象有原型 所有的对象在默认的情况下都有一个原型，因为原型本身也是对象，所以每个原型自身又有一个原型(只有一种例外，默认的对象原型在原型链的顶端。更多关于原型链的将在后面介绍) 好吧，再绕回来，那什么又是对象呢? 在javascript中，一个对象就是任何无序键值对的集合,如果它不是一个主数据类型(undefined，null，boolean，number，or string)，那它就是一个对象 你说每个对象都有一个原型，可是我当我写成({}).prototype 我得到了一个null，你说的不对吧？ 忘记你已经学到的关于原型属性的一切，它可能就是你对原型困惑的根源所在。一个对象的真正原型是被对象内部的[[Prototype]]属性(property)所持有。ECMA引入了标准对象原型访问器Object.getPrototype(object)，到目前为止只有Firefox和chrome实现了此访问器。除了IE，其他的浏览器支持非标准的访问器proto，如果这两者都不起作用的，我们需要从对象的构造函数中找到的它原型属性。下面的代码展示了获取对象原型的方法 var a = {}; //Firefox 3.6 and Chrome 5 Object.getPrototypeOf(a); //[object Object] //Firefox 3.6, Chrome 5 and Safari 4 a.proto; //[object Object] //all browsers a.constructor.prototype; //[object Object] ok，一切都进行的很好，但是false明明是一个主数据类型，可是false.proto却返回了一个值 当你试图获取一个主数据类型的原型时，它被强制转化成了一个对象 //(works in IE too, but only by accident) false.proto === Boolean(false).proto; //true 我想在继承中使用原型，那我该怎么做？ 如果仅仅只是因为一个实例而使用原型是没有多大意义的，这和直接添加属性到这个实例是一样的，假如我们已经创建了一个实例对象 ，我们想要继承一个已经存在的对象的功能比如说Array，我们可以像下面这样做( 在支持proto 的浏览器中) //unusual case and does not work in IE var a = {}; a.proto = Array.prototype; a.length; //0 译者注:上面这个例子中，首先创建了一个对象a，然后通过a的原型来达到继承Array 这个已经存在的对象的功能 原型真正魅力体现在多个实例共用一个通用原型的时候。原型对象(注:也就是某个对象的原型所引用的对象)的属性一旦定义，就可以被多个引用它的实例所继承(注:即这些实例对象的原型所指向的就是这个原型对象)，这种操作在性能和维护方面其意义是不言自明的 这也是构造函数的存在的原因么? 是的。构造函数提供了一种方便的跨浏览器机制，这种机制允许在创建实例时为实例提供一个通用的原型 在你能够提供一个例子之前，我需要知道constructor.prototype 属性究竟是什么？ 首先，javascript并没有在构造函数(constructor)和其他函数之间做区分，所以说每个函数都有一个原型属性。反过来，如果不是函数，将不会有这样一个属性。请看下面的代码 //function will never be a constructor but it has a prototype property anyway Math.max.prototype; //[object Object] //function intended to be a constructor has a prototype too var A = function(name) { this.name = name; } A.prototype; //[object Object] //Math is not a function so no prototype property Math.prototype; //null 现在我们可以下个定义了：函数A的原型属性(prototype property )是一个对象，当这个函数被用作构造函数来创建实例时，该函数的原型属性将被作为原型赋值给所有对象实例(注:即所有实例的原型引用的是函数的原型属性) 译者注:以下的代码更详细的说明这一切 //创建一个函数b var b = function(){ var one; } //使用b创建一个对象实例c var c = new b(); //查看b 和c的构造函数 b.constructor; // function Function() { [native code]} b.constructor==Function.constructor; //true c.constructor; //实例c的构造函数 即 b function(){ var one; } c.constructor==b //true //b是一个函数，查看b的原型如下 b.constructor.prototype // function (){} b.proto //function (){} //b是一个函数，由于javascript没有在构造函数constructor和函数function之间做区分，所以函数像constructor一样， //有一个原型属性，这和函数的原型(b.proto 或者b.construtor.prototype)是不一样的 b.prototype //[object Object] 函数b的原型属性 b.prototype==b.constructor.prototype //fasle b.prototype==b.proto //false b.proto==b.constructor.prototype //true //c是一个由b创建的对象实例，查看c的原型如下 c.constructor.prototype //[object Object] 这是对象的原型 c.proto //[object Object] 这是对象的原型 c.constructor.prototype==b.constructor.prototype; //false c的原型和b的原型比较 c.constructor.prototype==b.prototype; //true c的原型和b的原型属性比较 //为函数b的原型属性添加一个属性max b.prototype.max = 3 //实例c也有了一个属性max c.max //3 上面的例子中，对象实例c的原型和函数的b的原型属性是一样的，如果改变b的原型属性，则对象实例c 的原型也会改变 理解一个函数的原型属性(function’s prototype property )其实和实际的原型(prototype)没有关系对我们来说至关重要 //(example fails in IE) var A = function(name) { this.name = name; } A.prototype == A.proto; //false A.proto == Function.prototype; //true - A’s prototype is set to its constructor’s prototype property 给个例子撒 你可能曾经上百次的像这样使用javascript，现在当你再次看到这样的代码的时候，你或许会有不同的理解。 //Constructor. this is returned as new object and its internal [[prototype]] property will be set to the constructor’s default prototype property var Circle = function(radius) { this.radius = radius; //next line is implicit, added for illustration only //this.__proto__ = Circle.prototype; } //augment Circle’s default prototype property thereby augmenting the prototype of each generated instance Circle.prototype.area = function() { return Math.PI*this.radius*this.radius; } //create two instances of a circle and make each leverage the common prototype var a = new Circle(3), b = new Circle(4); a.area().toFixed(2); //28.27 b.area().toFixed(2); //50.27 棒极了。如果我更改了构造函数的原型，是否意味着已经存在的该构造函数的实例将获得构造函数的最新版本？ 不一定。如果修改的是原型属性，那么这样的改变将会发生。因为在a实际被创建之后，a.proto是一个对A.prototype 的一个引用，。 var A = function(name) { this.name = name; } var a = new A(‘alpha’); a.name; //‘alpha’ A.prototype.x = 23; a.x; //23 译者注:这个和上例中的一样，实例对象a的原型(a.proto)是对函数A的原型属性(A.prototype)的引用，所以如果修改的是A的原型属性， 改变将影响由A创建的对象实例a 在下面的例子中，但是对函数A的原型进行了修改，但是并没有反应到A所创建的实例a中 var A = function(name) { this.name = name; } var a = new A(‘alpha’); a.name; //’alpha’ A.proto.max = 19880716; a.max //undefined 但是如果我现在替换A的原型属性为一个新的对象，实例对象的原型a.proto却仍然引用着原来它被创建时A的原型属性 var A = function(name) { this.name = name; } var a = new A(‘alpha’); a.name; //‘alpha’ A.prototype = {x:23}; a.x; //null 译者注：即如果在实例被创建之后，改变了函数的原型属性所指向的对象，也就是改变了创建实例时实例原型所指向的对象 但是这并不会影响已经创建的实例的原型。 一个默认的原型是什么样子的？ var A = function() {}; A.prototype.constructor == A; //true var a = new A(); a.constructor == A; //true (a’s constructor property inherited from it’s prototype) instance of 和原型有什么关系 如果a的原型属于A的原型链，表达式 a instance of A 值为true。这意味着 我们可以对instance of 耍个诡计让它不在起作用 var A = function() {} var a = new A(); a.proto == A.prototype; //true - so instanceof A will return true a instanceof A; //true; //mess around with a’s prototype a.proto = Function.prototype; //a’s prototype no longer in same prototype chain as A’s prototype property a instanceof A; //false 还能使用原型做些什么呢? 记住我曾经所提到过的每个构造函数都有一个原型属性，它用来为每一个它所创建的实例提供原型。这同样也适用原生态的构造函数Function,String等，扩展这个属性，我们可以达到扩展指定构造函数的所有实例 我曾经在之前的很多文章中使用过这个技巧来演示函数的拓展。在tracer utility 这篇文章中所有的string实例都实现了times这个方法，对字符串本身进行指定数目的复制 String.prototype.times = function(count) { return count &lt; 1 ? &apos;&apos; : new Array(count + 1).join(this); } “hello!”.times(3); //“hello!hello!hello!”; “please…”.times(6);//“please…please…please…please…please…please…” 告诉我继承是怎样通过原型来工作的。什么是原型链? 因为每个对象和原型都有一个原型(注:原型也是一个对象)，对象的原型指向对象的父，而父的原型又指向父的父，我们把这种通过原型层层连接起来的关系撑为原型链。这条链的末端一般总是默认的对象原型。 a.proto = b; b.proto = c; c.proto = {}; //default object {}.proto.proto; //null 原型的继承机制是发生在内部且是隐式的.当想要获得一个对象a的属性foo的值，javascript会在原型链中查找foo的存在，如果找到则返回foo的值，否则undefined被返回。 赋值呢？ 原型的继承 is not a player 当属性值被设置成a.foo=’bar’是直接给a的属性foo设置了一个值bar。为了把一个属性添加到原型中，你需要直接指定该原型。 以上就是这篇文章所要讲述的。我个人感觉自己对原型概念的理解还是比较深刻的，但我的观点并不能代表一切。如有纰漏和异议，敬请告知。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"前端跨域请求原理及实践","date":"2017-02-17T12:55:39.000Z","path":"2017/02/17/前端跨域请求原理及实践/","text":"作者：高鹏 tingandpeng.com/2016/09/05/前端跨域请求原理及实践/ 如有好文章投稿，请点击 → 这里了解详情 一、 跨域请求的含义 浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用。 一般的，只要网站的 协议名protocol、 主机host、 端口号port 这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用。这也是我们下面实践的理论基础。我们利用 NodeJs 创建了两个服务器，分别监听 3000、 3001 端口（下面简称 服务器3000 与 服务器3001 ），由于端口号不一样，这两个服务器以及服务器上页面通信构成了跨域请求。 在服务器3000 上有如下的页面： 服务器3000 上的请求页面中包含如下 JavaScript 代码： $(function() { $(&quot;#submit&quot;).click(function() { var data = { name: $(&quot;#name&quot;).val(), id: $(&quot;#id&quot;).val() }; $.ajax({ type: &apos;POST&apos;, data: data, url: &apos;http://localhost:3000/ajax/deal&apos;, dataType: &apos;json&apos;, cache: false, timeout: 5000, success: function(data) { console.log(data) }, error: function(jqXHR, textStatus, errorThrown) { console.log(&apos;error &apos; + textStatus + &apos; &apos; + errorThrown); } }); }); }); 服务器3000 对应的处理函数为 pp.post(‘/ajax/deal’, function(req, res) { console.log(&quot;server accept: &quot;, req.body.name, req.body.id) var data = { name: req.body.name + &apos; - server 3000 process&apos;, id: req.body.id + &apos; - server 3000 process&apos; } res.send(data) res.end() }) 请求页面返回结果： 此处数据处理成功。 由于数据请求一般都是由页面发送数据字段，服务器根据这些字段作相应的处理，如数据库查询，字符串操作等等。所以我们这里简单的处理数据（在数据后面加上字符串‘server 3000 process’），并且返回给浏览器，表示数据经过服务器端处理。 如果让 服务器3000 上的页面向 服务器 3001 发起请求会怎样呢？ 将请求页面中的 ajax 请求路径改为： $.ajax({ ... url: &apos;http://localhost:3001/ajax/deal&apos;, ... }); 服务器3001 对应的处理函数与 服务器3000 类似： app.post(‘/ajax/deal’, function(req, res) { console.log(&quot;server accept: &quot;, req.body.name, req.body.id) var data = { name: req.body.name + &apos; - server 3001 process&apos;, id: req.body.id + &apos; - server 3001 process&apos; } res.send(data) res.end() }) 结果如下： 结果证明了我们上面所说的端口号不同，发生了跨域请求的调用。 需要注意的是，服务器 3001 控制台有输出： server accept: chiaki 3001 这说明跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。 二、 利用 JSONP 实现跨域调用 说道跨域调用，可能大家首先想到的或者听说过的就是 JSONP 了。 2.1 什么是JSONP JSONP (JSON with Padding or JSON-P) is a JSON extension used by web developers to overcome the cross-domain restrictions imposed by browsers’ same-origin policy that limits access to resources retrieved from origins other than the one the page was served by. In layman’s terms, one website cannot just simply access the data from another website. It was developed because handling a browsers’ same origin policy can be difficult, so using JSONP abstracts the difficulties and makes it easier. JSON stands for “JavaScript Object Notation”, a format by which object fields are represented as key-value pairs which is used to represent data. JSONP 是 JSON 的一种使用模式，可以解决主流浏览器的跨域数据访问问题。其原理是根据 XmlHttpRequest 对象受到同源策略的影响，而 标签元素却不受同源策略影响，可以加载跨域服务器上的脚本，网页可以从其他来源动态产生 JSON 资料。用 JSONP 获取的不是 JSON 数据，而是可以直接运行的 JavaScript 语句。 2.2 使用 jQuery 集成的 $.ajax 实现 JSONP 跨域调用 我们先从简单的实现开始，利用 jQuery 中的 $.ajax 来实现上诉的跨域调用。 依然是上面的例子，我们将 服务器 3000 上的请求页面的 JavaScript 代码改为： // 回调函数 function jsonpCallback(data) { console.log(&quot;jsonpCallback: &quot; + data.name) } $(“#submit”).click(function() { var data = { name: $(&quot;#name&quot;).val(), id: $(&quot;#id&quot;).val() }; $.ajax({ url: &apos;http://localhost:3001/ajax/deal&apos;, data: data, dataType: &apos;jsonp&apos;, cache: false, timeout: 5000, // jsonp 字段含义为服务器通过什么字段获取回调函数的名称 jsonp: &apos;callback&apos;, // 声明本地回调函数的名称，jquery 默认随机生成一个函数名称 jsonpCallback: &apos;jsonpCallback&apos;, success: function(data) { console.log(&quot;ajax success callback: &quot; + data.name) }, error: function(jqXHR, textStatus, errorThrown) { console.log(textStatus + &apos; &apos; + errorThrown); } }); }); 服务器 3001 上对应的处理函数为： app.get(‘/ajax/deal’, function(req, res) { console.log(&quot;server accept: &quot;, req.query.name, req.query.id) var data = &quot;{&quot; + &quot;name:&apos;&quot; + req.query.name + &quot; - server 3001 process&apos;,&quot; + &quot;id:&apos;&quot; + req.query.id + &quot; - server 3001 process&apos;&quot; +&quot;}&quot; var callback = req.query.callback var jsonp = callback + &apos;(&apos; + data + &apos;)&apos; console.log(jsonp) res.send(jsonp) res.end() }) 这里一定要注意 data 中字符串拼接，不能直接将 JSON 格式的 data 直接传给回调函数，否则会发生编译错误： parsererror Error: jsonpCallback was not called。 其实脑海里应该有一个概念：利用 JSONP 格式返回的值一段要立即执行的 JavaScript 代码，所以不会像 ajax 的 XmlHttpRequest 那样可以监听不同事件对数据进行不同处理。 处理结果如下所示： 2.3 使用 标签原生实现 JSONP 经过上面的事件，你是不是觉得 JSONP 的实现和 Ajax 大同小异？ 其实，由于实现的原理不同，由 JSONP 实现的跨域调用不是通过 XmlHttpRequset 对象，而是通过 script 标签，所以在实现原理上，JSONP 和 Ajax 已经一点关系都没有了。看上去形式相似只是由于 jQuery 对 JSONP 做了封装和转换。 比如在上面的例子中，我们假设要传输的数据 data 格式如下： { name: &quot;chiaki&quot;, id&quot;: &quot;3001&quot; } 那么数据是如何传输的呢？HTTP 请求头的第一行如下： GET /ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032 HTTP/1.1 可见，即使形式上是用 POST 传输一个 JSON 格式的数据，其实发送请求时还是转换成 GET 请求。 其实如果理解 JSONP 的原理的话就不难理解为什么只能使用 GET 请求方法了。由于是通过 script 标签进行请求，所以上述传输过程根本上是以下的形式： 这样从服务器返回的代码就可以直接在这个 script 标签中运行了。下面我们自己实现一个 JSONP： 服务器 3000请求页面的 JavaScript 代码中，只有回调函数 jsonpCallback： function jsonpCallback(data) { console.log(&quot;jsonpCallback: &quot;+data.name) } 服务器 3000请求页面还包含一个 script 标签： 服务器 3001上对应的处理函数： app.get(‘/jsonServerResponse’, function(req, res) { var cb = req.query.jsonp console.log(cb) var data = &apos;var data = {&apos; + &apos;name: $(&quot;#name&quot;).val() + &quot; - server 3001 jsonp process&quot;,&apos; + &apos;id: $(&quot;#id&quot;).val() + &quot; - server 3001 jsonp process&quot;&apos; + &apos;};&apos; var debug = &apos;console.log(data);&apos; var callback = &apos;$(&quot;#submit&quot;).click(function() {&apos; + data + cb + &apos;(data);&apos; + debug + &apos;});&apos; res.send(callback) res.end() }) 与上面一样，我们在所获取的参数后面加上 “ – server 3001 jsonp process” 代表服务器对数据的操作。从代码中我么可以看到，处理函数除了根据参数做相应的处理，更多的也是进行字符串的拼接。 最终的结果为： 2.4 JSONP 总结 至此，我们了解了 JSONP 的原理以及实现方式，它帮我们实现前端跨域请求，但是在实践的过程中，我们还是可以发现它的不足： 只能使用 GET 方法发起请求，这是由于 script 标签自身的限制决定的。 不能很好的发现错误，并进行处理。与 Ajax 对比，由于不是通过 XmlHttpRequest 进行传输，所以不能注册 success、 error 等事件监听函数。 三、 使用 CORS 实现跨域调用 3.1 什么是 CORS？ Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。 3.2 CORS 的实现 还是以 服务器 3000 上的请求页面向 服务器 3001 发送请求为例。 服务器 3000 上的请求页面 JavaScript 不变，如下： $(function() { $(&quot;#submit&quot;).click(function() { var data = { name: $(&quot;#name&quot;).val(), id: $(&quot;#id&quot;).val() }; $.ajax({ type: &apos;POST&apos;, data: data, url: &apos;http://localhost:3001/cors&apos;, dataType: &apos;json&apos;, cache: false, timeout: 5000, success: function(data) { console.log(data) }, error: function(jqXHR, textStatus, errorThrown) { console.log(&apos;error &apos; + textStatus + &apos; &apos; + errorThrown); } }); }); }); 服务器 3001上对应的处理函数： app.post(‘/cors’, function(req, res) { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;) res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); var data = { name: req.body.name + &apos; - server 3001 cors process&apos;, id: req.body.id + &apos; - server 3001 cors process&apos; } console.log(data) res.send(data) res.end() }) 在服务器中对返回信息的请求头进行了设置。 最终的结果为： 3.3 CORS 中属性的分析 Access-Control-Allow-Origin The origin parameter specifies a URI that may access the resource. The browser must enforce this. For requests without credentials, the server may specify “*” as a wildcard, thereby allowing any origin to access the resource. Access-Control-Allow-Methods Specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above. Access-Control-Allow-Headers Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request. 3.4 CORS 与 JSONP 的对比 CORS 除了 GET 方法外，也支持其它的 HTTP 请求方法如 POST、 PUT 等。 CORS 可以使用 XmlHttpRequest 进行传输，所以它的错误处理方式比 JSONP 好。 JSONP 可以在不支持 CORS 的老旧浏览器上运作。 四、 一些其它的跨域调用方式 4.1 window.name window对象有个name属性，该属性有个特征：即在一个窗口 (window) 的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 4.2 window.postMessage() 这个方法是 HTML5 的一个新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了他，就会让后面的函数超时无法执行。 参考：https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage","tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"MVVM和Vue.js","date":"2016-09-10T15:57:52.000Z","path":"2016/09/10/MVVM和Vue-js/","text":"MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。 Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 为什么会出现 MVVM 呢？ 我接触MVVM 是在2015年，可以说2015年是MVVM 最火热的一年，而在这之前，我所知道的就是MVC, MVC 大约是在5年前，也就是2011年的时候接触的，那时候刚学编程语言，学的Java，而Java 中经典的 SSH 框架就用来构建一个标准的MVC 框架。说实话，MVC 用了这么多年，但始终没有很深刻的理解，只停留在用的层面， 一直到接触 Vue.js 之后，研究了MVVM 架构思想，然后再回头看 MVC ，才有一种豁然开朗的感觉~ MVC 即 Model-View-Controller 的缩写，就是 模型-视图-控制器 , 也就是说一个标准的Web 应用程式是由这三部分组成的： View 用来把数据以某种方式呈现给用户 Model 其实就是数据 Controller 接收并处理来自用户的请求，并将 Model 返回给用户 在HTML5 还未火起来的那些年，MVC 作为Web 应用的最佳实践是OK 的，这是因为 Web 应用的View 层相对来说比较简单，前端所需要的数据在后端基本上都可以处理好，View 层主要是做一下展示，那时候提倡的是 Controller 来处理复杂的业务逻辑，所以View 层相对来说比较轻量，就是所谓的瘦客户端思想。 2010年到2011年，HTML5概念被热炒，受到追捧，2012年，W3C 正式宣布HTML5规范已经正式定稿。2013年我刚进公司就接触了第一个 HTML5 框架Sench touch, 它是一款用来构建移动应用的HTML5 框架，它将前后端彻底分离，前端采用MVC 架构，作为一个独立的项目工程来维护。 为什么前端要工程化，要是使用MVC？ 相对 HTML4 , HTML5 最大的亮点是它为移动设备提供了一些非常有用的功能，使得 HTML5 具备了开发App的能力, HTML5开发App 最大的好处就是跨平台、快速迭代和上线，节省人力成本和提高效率，因此很多企业开始对传统的App进行改造，逐渐用H5代替Native，到2015年的时候，市面上大多数App 或多或少嵌入都了H5 的页面。 既然要用H5 来构建 App, 那View 层所做的事，就不仅仅是简单的数据展示了，它不仅要管理复杂的数据状态，还要处理移动设备上各种操作行为等等。因此，前端也需要工程化，也需要一个类似于MVC 的框架来管理这些复杂的逻辑，使开发更加高效。 但这里的 MVC 又稍微发了点变化： View UI布局，展示数据 Model 管理数据 Controller 响应用户操作，并将 Model 更新到 View 上 这种 MVC 架构模式对于简单的应用来看起是OK 的，也符合软件架构的分层思想。 但实际上，随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题： 开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。 其实，早期jquery 的出现就是为了前端能更简洁的操作DOM 而设计的，但它只解决了第一个问题，另外两个问题始终伴随着前端一直存在。 MVVM 的出现，完美解决了以上三个问题。 MVVM 由 Model,View,ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 Vue.js 的细节 Vue.js 可以说是MVVM 架构的最佳实践，专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对来比较轻量级的JS 库，API 简洁，很容易上手。Vue的基础知识网上有现成的教程，此处不再赘述， 下面简单了解一下 Vue.js 关于双向绑定的一些实现细节： Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现 Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数 Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的update 方法 从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。 当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。","tags":[{"name":"MVVM","slug":"MVVM","permalink":"http://yoursite.com/tags/MVVM/"}]},{"title":"node.js的一些小知识","date":"2016-07-20T12:54:48.000Z","path":"2016/07/20/node-js的一些小知识/","text":"querystring:可以用作通用解析器的模块很多时候我们会从数据库或其他地方得到这种奇怪格式的字符串:name:Sophie;shape:fox;condition:new，一般来说我们会利用字符串切割的方式来讲字符串划分到JavaScript Object。不过querystring也是个不错的现成的工具: const weirdoString = name:Sophie;shape:fox;condition:new; const result = querystring.parse(weirdoString, ;, :); // result: // { // name: Sophie, // shape: fox, // condition: new, // }; V8 Inspector以--inspect参数运行你的Node应用程序，它会反馈你某个URL。将该URL复制到Chrome中并打开，你就可以使用Chrome DevTools来调试你的Node应用程序啦。详细的实验可以参考这篇文章。不过需要注意的是，该参数仍然属于实验性质 nextTick 与 setImmediate的区别这两货的区别可能光从名字上还看不出来，我觉得应该给它们取个别名: process.nextTick()应该为process.sendThisToTheStartOfTheQueue() setImmediate应该为sendThisToTheEndOfTheQueue() 再说句不相关的，React中的Props应该为stuffThatShouldStayTheSameIfTheUserRefreshes，而State应该为stuffThatShouldBeForgottenIfTheUserRefreshes。 Server.listen 可以使用Object作为参数我更喜欢命名参数的方式调用函数，这样相较于仅按照顺序的无命名参数法会更直观。别忘了Server.listen也可以使用某个Object作为参数: require(http) .createServer() .listen({ port: 8080, host: `localhost`, }) .on(request, (req, res) =&gt; { res.end(`Hello World!`); }); 不过这个特性不是表述在http.Server这个API中，而是在其父级net.Server的文档中。 相对地址你传入fs模块的距离可以是相对地址，即相对于process.cwd()。估计有些人早就知道了，不过我之前一直以为是只能使用绝对地址: const fs = require(fs); const path = require(path); // why have I always done this… fs.readFile(path.join(__dirname, myFile.txt), (err, data) =&gt; { // do something }); // when I could just do this? fs.readFile(./path/to/myFile.txt, (err, data) =&gt; { // do something }); Path Parsing:路径解析之前我一直不知道的某个功能就是从某个文件名中解析出路径，文件名，文件扩展等等: myFilePath = /someDir/someFile.json; path.parse(myFilePath).base === someFile.json; // true path.parse(myFilePath).name === someFile; // true path.parse(myFilePath).ext === .json; // true Logging with colors别忘了console.dir(obj,{colors:true})能够以不同的色彩打印出键与值，这一点会大大增加日志的可读性。 使用setInterval执行定时任务我喜欢使用setInterval来定期执行数据库清理任务，不过默认情况下在存在setInterval的时候NodeJS并不会退出，你可以使用如下的方法让Node沉睡: const dailyCleanup = setInterval(() =&gt; { cleanup(); }, 1000 60 60 * 24); dailyCleanup.unref(); Use Signal Constants如果你尝试在NodeJS中杀死某个进程，估计你用过如下语法: process.kill(process.pid, SIGTERM); 这个没啥问题，不过既然第二个参数同时能够使用字符串与整形变量，那么还不如使用全局变量呢: process.kill(process.pid, os.constants.signals.SIGTERM); IP Address ValidationNodeJS中含有内置的IP地址校验工具，这一点可以免得你写额外的正则表达式: require(net).isIP(10.0.0.1) 返回 4 require(net).isIP(cats) 返回 0 os.EOF不知道你有没有手写过行结束符，看上去可不漂亮啊。NodeJS内置了os.EOF，其在Windows下是rn，其他地方是n，使用os.EOL能够让你的代码在不同的操作系统上保证一致性: const fs = require(fs); // bad fs.readFile(./myFile.txt, utf8, (err, data) =&gt; { data.split(\\r\\n).forEach(line =&gt; { // do something }); }); // good const os = require(os); fs.readFile(./myFile.txt, utf8, (err, data) =&gt; { data.split(os.EOL).forEach(line =&gt; { // do something }); }); HTTP 状态码NodeJS帮我们内置了HTTP状态码及其描述，也就是http.STATUS_CODES，键为状态值，值为描述: 你可以按照如下方法使用: someResponse.code === 301; // true require(http).STATUS_CODES[someResponse.code] === Moved Permanently; // true 避免异常崩溃有时候碰到如下这种导致服务端崩溃的情况还是挺无奈的: const jsonData = getDataFromSomeApi(); // But oh no, bad data! const data = JSON.parse(jsonData); // Loud crashing noise. 我为了避免这种情况，在全局加上了一个: process.on(uncaughtException, console.error); 当然，这种办法绝不是最佳实践，如果是在大型项目中我还是会使用PM2，然后将所有可能崩溃的代码加入到try...catch中。 Just this once()除了on方法，once方法也适用于所有的EventEmitters，希望我不是最后才知道这个的: server.once(request, (req, res) =&gt; res.end(No more from me.)); Custom Console你可以使用new console.Console(standardOut,errorOut)，然后设置自定义的输出流。你可以选择创建console将数据输出到文件或者Socket或者第三方中。 DNS lookup某个年轻人告诉我，Node并不会缓存DNS查询信息，因此你在使用URL之后要等个几毫秒才能获取到数据。不过其实你可以使用dns.lookup()来缓存数据: dns.lookup(www.myApi.com, 4, (err, address) =&gt; { cacheThisForLater(address); }); fs 在不同OS上有一定差异 fs.stats()返回的对象中的mode属性在Windows与其他操作系统中存在差异。 fs.lchmod()仅在macOS中有效。 仅在Windows中支持调用fs.symlink()时使用type参数。 仅仅在macOS与Windows中调用fs.watch()时传入recursive选项。 在Linux与Windows中fs.watch()的回调可以传入某个文件名 使用fs.open()以及a+属性打开某个目录时仅仅在FreeBSD以及Windows上起作用，在macOS以及Linux上则存在问题。 在Linux下以追加模式打开某个文件时，传入到fs.write()的position参数会被忽略。 net 模块差不多比http快上两倍笔者在文档中看到一些关于二者性能的讨论，还特地运行了两个服务器来进行真实比较。结果来看http.Server大概每秒可以接入3400个请求，而net.Server可以接入大概5500个请求。 // This makes two connections, one to a tcp server, one to an http server (both in server.js) // It fires off a bunch of connections and times the response // Both send strings. const net = require(net); const http = require(http); function parseIncomingMessage(res) { return new Promise((resolve) =&gt; { let data = ``; res.on(`data`, (chunk) =&gt; { data += chunk; }); res.on(`end`, () =&gt; resolve(data)); }); } const testLimit = 5000; / —————— / / – NET client – / / —————— / function testNetClient() { const netTest = { startTime: process.hrtime(), responseCount: 0, testCount: 0, payloadData: { type: `millipede`, feet: 100, test: 0, }, }; function handleSocketConnect() { netTest.payloadData.test++; netTest.payloadData.feet++; const payload = JSON.stringify(netTest.payloadData); this.end(payload, `utf8`); } function handleSocketData() { netTest.responseCount++; if (netTest.responseCount === testLimit) { const hrDiff = process.hrtime(netTest.startTime); const elapsedTime = hrDiff[0] * 1e3 + hrDiff[1] / 1e6; const requestsPerSecond = (testLimit / (elapsedTime / 1000)).toLocaleString(); console.info(`net.Server handled an average of ${requestsPerSecond} requests per second.`); } } while (netTest.testCount &lt; testLimit) { netTest.testCount++; const socket = net.connect(8888, handleSocketConnect); socket.on(`data`, handleSocketData); } } / ——————- / / – HTTP client – / / ——————- / function testHttpClient() { const httpTest = { startTime: process.hrtime(), responseCount: 0, testCount: 0, }; const payloadData = { type: `centipede`, feet: 100, test: 0, }; const options = { hostname: `localhost`, port: 8080, method: `POST`, headers: { &apos;Content-Type&apos;: `application/x-www-form-urlencoded`, }, }; function handleResponse(res) { parseIncomingMessage(res).then(() =&gt; { httpTest.responseCount++; if (httpTest.responseCount === testLimit) { const hrDiff = process.hrtime(httpTest.startTime); const elapsedTime = hrDiff[0] * 1e3 + hrDiff[1] / 1e6; const requestsPerSecond = (testLimit / (elapsedTime / 1000)).toLocaleString(); console.info(`http.Server handled an average of ${requestsPerSecond} requests per second.`); } }); } while (httpTest.testCount &lt; testLimit) { httpTest.testCount++; payloadData.test = httpTest.testCount; payloadData.feet++; const payload = JSON.stringify(payloadData); options[`Content-Length`] = Buffer.byteLength(payload); const req = http.request(options, handleResponse); req.end(payload); } } / – Start tests – / // flip these occasionally to ensure there’s no bias based on order setTimeout(() =&gt; { console.info(Starting testNetClient()); testNetClient(); }, 50); setTimeout(() =&gt; { console.info(Starting testHttpClient()); testHttpClient(); }, 2000); // This sets up two servers. A TCP and an HTTP one. // For each response, it parses the received string as JSON, converts that object and returns a string const net = require(net); const http = require(http); function renderAnimalString(jsonString) { const data = JSON.parse(jsonString); return ${data.test}: your are a ${data.type} and you have ${data.feet} feet.; } / —————— / / – NET server – / / —————— / net .createServer((socket) =&gt; { socket.on(`data`, (jsonString) =&gt; { socket.end(renderAnimalString(jsonString)); }); }) .listen(8888); / ——————- / / – HTTP server – / / ——————- / function parseIncomingMessage(res) { return new Promise((resolve) =&gt; { let data = ``; res.on(`data`, (chunk) =&gt; { data += chunk; }); res.on(`end`, () =&gt; resolve(data)); }); } http .createServer() .listen(8080) .on(request, (req, res) =&gt; { parseIncomingMessage(req).then((jsonString) =&gt; { res.end(renderAnimalString(jsonString)); }); }); REPL tricks 如果你是在REPL模式下，就是直接输入node然后进入交互状态的模式。你可以直接输入.load someFile.js然后可以载入包含自定义常量的文件。 可以通过设置NODE_REPL_HISTORY=&quot;&quot;来避免将日志写入到文件中。 _用来记录最后一个计算值。 在REPL启动之后，所有的模块都已经直接加载成功。可以使用os.arch()而不是require(os).arch()来使用。","tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]},{"title":"原生JS","date":"2016-05-18T14:04:59.000Z","path":"2016/05/18/原生JS/","text":"数据类型基本类型值包括： undefined，null，Boolean，Number和String，这些类型分别在内存中占有固定的大小空间，它们的值保存在栈空间，我们通过按值来访问的。引用类型包括：对象、数组、函数等。对于引用类型的值，则必须在堆内存中为这个值分配空间。由于引用类型值的大小不固定（对象有很多属性和方法，而且还可以动态的添加属性和方法），因此不能把他们保存到栈内存中。但内存地址大小是固定的，因此可以将内存地址保存在栈内存中。 简而言之：栈内存中存放的是基本数据类型值，堆内存中存放的是引用类型值，引用类型值在内存中的地址存放在栈中，也就是我们常说的对象对象引用(指针)。 变量复制12345678910111213&lt;script type=&quot;text/javascript&quot;&gt;var a = 5;var b = a;console.log(a+&quot;---&quot;+b);//5---5b = 6;//这里重新给b赋值，a值并没有改变console.log(a+&quot;---&quot;+b);//5---6var obj = &#123;name:&quot;lisi&quot;&#125;;var obj2 = obj;//这里是引用赋值，obj和obj2指向同一个对象console.log(obj.name + &quot;---&quot; + obj2.name);//lisi---lisiobj2.name = &quot;wangwu&quot;;console.log(obj.name + &quot;---&quot; + obj2.name);//wangwu---wangwu&lt;/script&gt;1234567891011121312345678910111213 从上面例子可以看出：在变量复制方面，基本类型和引用类型也有所不同，基本类型复制的是值本身，而引用类型复制的是内存地址。 函数this 的工作原理(5种情况)全局作用域内当在全部作用域内使用 this时，它将会指向全局对象，即window对象 函数调用挡在全局作用域内调用函数时，this 也会指向全局对象。 方法调用this 指向调用该方法的对象。 调用构造函数在构造函数内部，this 指向新创建的对象。 显式的设置this指向当使用call 或者 apply 方法时，函数内的 this 将会被显式设置为函数调用的第一个参数。更详细用法请见之前的博客：传送门 匿名函数在JavaScript里任何匿名函数都是属于window对象。在定义匿名函数时候它会返回自己的内存地址，如果此时有个变量接收了这个内存地址，那么匿名函数就能在程序里被使用了(可以通过在这个变量后面加一对圆括号来调用这个匿名函数)，因为匿名函数也是在全局执行环境构造时候定义和赋值，所以匿名函数的this指向也是window对象。 12345&lt;script type=&quot;text/javascript&quot;&gt;(function()&#123; console.log(this == window);//true&#125;)();&lt;/script&gt;1234512345 参数传递1234567891011&lt;script type=&quot;text/javascript&quot;&gt; function test(num)&#123;//按值传递 num+=5; console.log(num); return num; &#125; var num = 5; var result = test(num); console.log(result);// 10 如果是按引用传递，那么函数里的num会成为类似全局变量，把外面的num覆盖掉 console.log(num);// 5 也就是说，最后应该输出20（这里输出10）&lt;/script&gt;12345678910111234567891011 js中不存在引用传递，如果存在引用传递的话，那么函数内的变量将是全局变量，在外部也可以访问，但这明显是不可能的。再看一个例子： 1234567891011&lt;script type=&quot;text/javascript&quot;&gt;function setName(obj)&#123;//obj = person obj.name = &quot;lisi&quot;; obj = new Object(); obj.name = &quot;wangwu&quot;;&#125;var person = new Object();setName(person);alert(person.name);console.log(obj.name);//Uncaught ReferenceError: obj is not defined&lt;/script&gt;12345678910111234567891011 在将person传递给obj后，其name属性就被设置成了”lisi”。又将obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为”wangwu”的新对象，但事实上并没有，其name属性依然是”lisi”。这就说明：即使在函数内部修改了参数的值，但原始的引用仍然保持不变。实际上，当在函数内重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。 执行环境及作用域执行环境执行环境定义了变量或函数有权访问其他数据，可以分为全局执行环境和局部执行环境。全局执行环境是最外层的执行环境，在浏览器中，全局执行环境是window对象，因此，所有的全局变量的函数都是作为window的属性和方法创建的。注意：对于局部执行环境，其内部的代码执行完毕后，该环境将被销毁，保存其中的变量和函数也随之销毁，如果是全局执行环境，需所有程序执行完毕或网页完毕后才会销毁。 需要注意的小细节去掉var的局部变量12345678&lt;script type=&quot;text/javascript&quot;&gt; var name = &quot;wangwu&quot;; function setName()&#123; name = &quot;lisi&quot;;//去掉var变成了全局变量，会覆盖全局中的name &#125; setName(); console.log(name);//lisi&lt;/script&gt;1234567812345678 形参也是局部变量12345678&lt;script type=&quot;text/javascript&quot;&gt; var name = &quot;wangwu&quot;; function setName(name)&#123;//形参也是局部变量 console.log(name); &#125; setName(&quot;￼lisi&quot;);//lisi console.log(name);//wangwu&lt;/script&gt;1234567812345678 作用域当代码在一个环境中执行的时候，就会形成作用域链，它的作用是保证对执行环境中有访问权限的变量和函数进行有序访问（内部深层环境可以访问外层环境，反之不成立），作用域链的前端，就是执行环境的变量对象。详见之前博客：传送门 内存泄漏常见情况javascript具有自动垃圾回收机制，一旦数据不再使用，可以将其设为”null”来释放引用。 循环引用分为两种情况：不同对象之间相互引用和一个经典的例子：一个DOM对象被一个Javascript对象引用，与此同时又引用同一个或其它的Javascript对象，这个DOM对象可能会引发内存泄露。这个DOM对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏循环引用，引用DOM元素的对象或DOM对象的引用需要被赋值为null。 12345678&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;var oBox = document.getElementById(&quot;box&quot;);var obj = &#123;&#125;;oBox.name = obj;obj.age = oBox;//这样就发生了循环引用&lt;/script&gt;&lt;/body&gt;1234567812345678 闭包(常见)通过闭包引用其包含函数的局部变量，当闭包结束后该局部变量无法被垃圾回收机制回收，造成内存泄漏。 DOM泄漏当原有的DOM被移除时，子结点引用没有被移除则无法回收。 123456789101112var select = document.querySelector;var treeRef = select(&apos;#tree&apos;);//在COM树中leafRef是treeFre的一个子结点var leafRef = select(&apos;#leaf&apos;); var body = select(&apos;body&apos;);body.removeChild(treeRef);//#tree不能被回收入，因为treeRef还在//解决方法:treeRef = null;//tree还不能被回收，因为叶子结果leafRef还在leafRef = null;//现在#tree可以被释放了。123456789101112123456789101112 定时器泄漏12345678910111213for (var i = 0; i &lt; 1000; i++) &#123; var obj = &#123; fn: function() &#123; var that = this; var val = setTimeout(function() &#123; that.fn(); &#125;, 500); &#125; &#125; obj.fn(); //虽然你想回收但是timer还在 obj = null;&#125;1234567891011121312345678910111213 垃圾回收标记清除js中最常用的垃圾回收方式就是标记清除。垃圾收集器在运行的时候回给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，消除那些带标记的值并回收它们所占用的内存空间。例如:在函数中声明一个变量，就将这个变量标记为”进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为”离开环境”。 12345function test()&#123; var x = 10 ; //被标记 ，进入环境 var y = 20 ; //被标记 ，进入环境&#125;test(); //执行完毕后 x、y又被标离开环境，被回收。1234512345 引用计数引用计数就是：跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 123456function test()&#123; var x = &#123;&#125; ; //x的引用次数为0 var y = x ; //x的引用次数加1，为1 var z =x; //x的引用次数再加1，为2 var y =&#123;&#125;; //x的引用次数减1，为1&#125;123456123456 引用计数策略的问题(循环引用)1234567function test() &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.name = b; b.name = a;&#125;test();12345671234567 以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄露。在IE7与IE8上，内存直线上升。我们知道，IE中有一部分对象并不是原生js对象。例如，其BOM和DOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。 12345var element = document.getElementById(&quot;some_element&quot;);var myObject = new Object();myObject.element = element;element.someObject = myObject;//产生了循环引用12341234 这个例子在一个DOM元素（element)与一个原生js对象（myObject)之间创建了循环引用。其中，变量myObject有一个名为element的属性指向element对象；而变量element也有一个someObject属性指向myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。 12myObject.element = null;element.someObject = null;1212 为了避免类似这样的循环引用问题，最好在不使用它们的时候手工断开原生js对象与DOM元素之间的连接。将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。注意：为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的js对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"详细图解作用域链与闭包","date":"2016-03-18T13:24:03.000Z","path":"2016/03/18/详细图解作用域链与闭包/","text":"攻克闭包难题 初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。 闭包有多重要？如果你是初入前端的朋友，我没有办法直观的告诉你闭包在实际开发中的无处不在，但是我可以告诉你，前端面试，必问闭包。面试官们常常用对闭包的了解程度来判定面试者的基础水平，保守估计，10个前端面试者，至少5个都死在闭包上。 可是为什么，闭包如此重要，还是有那么多人没有搞清楚呢？是因为大家不愿意学习吗？还真不是，而是我们通过搜索找到的大部分讲解闭包的中文文章，都没有清晰明了的把闭包讲解清楚。要么浅尝辄止，要么高深莫测，要么干脆就直接乱说一通。包括我自己曾经也写过一篇关于闭包的总结，回头一看，不忍直视[捂脸]。 因此本文的目的就在于，能够清晰明了得把闭包说清楚，让读者老爷们看了之后，就把闭包给彻底学会了，而不是似懂非懂。 一、作用域与作用域链 在详细讲解作用域链之前，我默认你已经大概明白了JavaScript中的下面这些重要概念。这些概念将会非常有帮助。 基础数据类型与引用数据类型 内存空间 垃圾回收机制 执行上下文 变量对象与活动对象 如果你暂时还没有明白，可以去看本系列的前三篇文章，本文文末有目录链接。为了讲解闭包，我已经为大家做好了基础知识的铺垫。哈哈，真是好大一出戏。 作用域 在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 这里的标识符，指的是变量名或者函数名 JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。 作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 作用域链 回顾一下上一篇文章我们分析的执行上下文的生命周期，如下图。 执行上下文生命周期 我们发现，作用域链是在执行上下文的创建阶段生成的。这个就奇怪了。上面我们刚刚说作用域在编译阶段确定规则，可是为什么作用域链却在执行阶段确定呢？ 之所有有这个疑问，是因为大家对作用域和作用域链有一个误解。我们上面说了，作用域是一套规则，那么作用域链是什么呢？是这套规则的具体实现。所以这就是作用域与作用域链的关系，相信大家都应该明白了吧。 我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。之前一篇文章我们详细说明了变量对象，而这里，我们将详细说明作用域链。 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 为了帮助大家理解作用域链，我我们先结合一个例子，以及相应的图示来说明。 var a = 20; function test() { var b = a + 10; function innerTest() { var c = 10; return b + c; } return innerTest(); } test(); 在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。 innerTestEC = { VO: {...}, // 变量对象 scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链 this: {} } 是的，你没有看错，我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。 很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。 作用域链图示 注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object 是的，作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。 二、闭包 对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。 闭包与作用域链息息相关； 闭包是在函数执行过程中被确认。 先直截了当的抛出闭包的定义：当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行。 简单来说，假设函数A在函数B的内部进行定义了，并且当函数A在执行时，访问了函数B内部的变量对象，那么B就是一个闭包。 非常抱歉之前对于闭包定义的描述有一些不准确，现在已经改过，希望收藏文章的同学再看到的时候能看到吧，对不起大家了。 在基础进阶（一）中，我总结了JavaScript的垃圾回收机制。JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。 而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。 先来一个简单的例子。 var fn = null; function foo() { var a = 2; function innnerFoo() { console.log(a); } fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn } function bar() { fn(); // 此处的保留的innerFoo的引用 } foo(); bar(); // 2 在上面的例子中，foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过fn = innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。 这样，我们就可以称foo为闭包。 下图展示了闭包fn的作用域链。 闭包fn的作用域链 我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。 从图中可以看出，chrome浏览器认为闭包是foo，而不是通常我们认为的 innerFoo在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。 所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。 不过读者老爷们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。 对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。 var fn = null; function foo() { var a = 2; function innnerFoo() { console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误 console.log(a); } fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn } function bar() { var c = 100; fn(); // 此处的保留的innerFoo的引用 } foo(); bar(); 闭包的应用场景 接下来，我们来总结下，闭包的常用场景。 延迟函数setTimeout 我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中， function fn() { console.log(&apos;this is test.&apos;) } var timer = setTimeout(fn, 1000); console.log(timer); 执行上面的代码，变量timer的值，会立即输出出来，表示setTimeout这个函数本身已经执行完毕了。但是一秒钟之后，fn才会被执行。这是为什么？ 按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。 很显然，这是在函数的内部实现中，setTimeout通过特殊的方式，保留了fn的引用，让setTimeout的变量对象，并没有在其执行完毕后被垃圾收集器回收。因此setTimeout执行结束后一秒，我们任然能够执行fn函数。 柯里化 在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化算是其中一种。关于柯里化，我会在以后详解函数式编程的时候仔细总结。 模块 在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。 (function () { var a = 10; var b = 20; function add(num1, num2) { var num1 = !!num1 ? num1 : a; var num2 = !!num2 ? num2 : b; return num1 + num2; } window.add = add; })(); add(10, 20); 在上面的例子中，我使用函数自执行的方式，创建了一个模块。方法add被作为一个闭包，对外暴露了一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。 此图中可以观看到当代码执行到add方法时的调用栈与作用域链，此刻的闭包为外层的自执行函数 为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。 利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5 for (var i=1; i&lt;=5; i++) { setTimeout( function timer() { console.log(i); }, i*1000 ); } 关于作用域链的与闭包我就总结完了，虽然我自认为我是说得非常清晰了，但是我知道理解闭包并不是一件简单的事情，所以如果你有什么问题，可以在评论中问我。你也可以带着从别的地方没有看懂的例子在评论中留言。大家一起学习进步。","tags":[{"name":"闭包/作用域","slug":"闭包-作用域","permalink":"http://yoursite.com/tags/闭包-作用域/"}]},{"title":"JavaScript的this指向问题深度解析","date":"2016-03-15T12:41:29.000Z","path":"2016/03/15/JavaScript的this指向问题深度解析/","text":"JavaScript 中的 this 指向问题有很多博客在解释，仍然有很多人问。上周我们的开发团队连续两个人遇到相关问题，所以我不得不将关于前端构建技术的交流会延长了半个时候讨论 this 的问题。 与我们常见的很多语言不同，JavaScript 函数中的 this 指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了 this 指向。 JavaScript 中，普通的函数调用方式有三种：直接调用、方法调用和 new 调用。除此之外，还有一些特殊的调用方式，比如通过bind() 将函数绑定到对象之后再进行调用、通过 call()、apply() 进行调用等。而 es6 引入了箭头函数之后，箭头函数调用时，其 this 指向又有所不同。下面就来分析这些情况下的 this 指向。 直接调用 直接调用，就是通过 函数名(…) 这种方式调用。这时候，函数内部的 this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。 来看一个例子： // 简单兼容浏览器和 NodeJs 的全局对象 const _global = typeof window === “undefined” ? global : window; function test() { console.log(this === _global); // true } test(); // 直接调用 这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(…) 来对函数进行调用的方式，都称为直接调用。比如下面这个例子也是直接调用 (function(_global) { // 通过 IIFE 限定作用域 function test() { console.log(this === _global); // true } test(); // 非全局作用域下的直接调用 })(typeof window === “undefined” ? global : window); bind() 对直接调用的影响 还有一点需要注意的是 bind() 的影响。Function.prototype.bind() 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。还是来看例子： const obj = {}; function test() { console.log(this === obj); } const testObj = test.bind(obj); test(); // false testObj(); // true 那么 bind() 干了啥？不妨模拟一个 bind() 来了解它是如何做到对 this 产生影响的。 const obj = {}; function test() { console.log(this === obj); } // 自定义的函数，模拟 bind() 对 this 的影响 function myBind(func, target) { return function() { return func.apply(target, arguments); }; } const testObj = myBind(test, obj); test(); // false testObj(); // true 从上面的示例可以看到，首先，通过闭包，保持了 target，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply 方法来指定函数的 this。当然原生的 bind() 实现可能会不同，而且更高效。但这个示例说明了 bind() 的可行性。 call 和 apply 对 this 的影响 上面的示例中用到了 Function.prototype.apply()，与之类似的还有 Function.prototype.call()。这两方法的用法请大家自己通过链接去看文档。不过，它们的第一个参数都是指定函数运行时其中的 this 指向。 不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行，比如 const obj = {}; function test() { console.log(this === obj); } // 绑定到一个新对象，而不是 obj const testObj = test.bind({}); test.apply(obj); // true // 期望 this 是 obj，即输出 true // 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false testObj.apply(obj); // false 由此可见，bind() 对函数的影响是深远的，慎用！ 方法调用 方法调用是指通过对象来调用其方法函数，它是 对象.方法函数(…) 这样的调用形式。这种情况下，函数中的 this 指向调用该方法的对象。但是，同样需要注意 bind() 的影响。 const obj = { // 第一种方式，定义对象的时候定义其方法 test() { console.log(this === obj); } }; // 第二种方式，对象定义好之后为其附加一个方法(函数表达式) obj.test2 = function() { console.log(this === obj); }; // 第三种方式和第二种方式原理相同 // 是对象定义好之后为其附加一个方法(函数定义) function t() { console.log(this === obj); } obj.test3 = t; // 这也是为对象附加一个方法函数 // 但是这个函数绑定了一个不是 obj 的其它对象 obj.test4 = (function() { console.log(this === obj); }).bind({}); obj.test(); // true obj.test2(); // true obj.test3(); // true // 受 bind() 影响，test4 中的 this 指向不是 obj obj.test4(); // false 这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 obj 对象作为其方法。再次强调，函数内部的 this 指向与定义无关，受调用方式的影响。 方法中 this 指向全局对象的情况 注意这里说的是方法中而不是方法调用中。方法中的 this 指向全局对象，如果不是因为 bind()，那就一定是因为不是用的方法调用方式，比如 const obj = { test() { console.log(this === obj); } }; const t = obj.test; t(); // false t 就是 obj 的 test 方法，但是 t() 调用时，其中的 this 指向了全局。 之所以要特别提出这种情况，主要是因为常常将一个对象方法作为回调传递给某个函数之后，却发现运行结果与预期不符——因为忽略了调用方式对 this 的影响。比如下面的例子是在页面中对某些事情进行封装之后特别容易遇到的问题： class Handlers { // 这里 $button 假设是一个指向某个按钮的 jQuery 对象 constructor(data, $button) { this.data = data; $button.on(&quot;click&quot;, this.onButtonClick); } onButtonClick(e) { console.log(this.data); } } const handlers = new Handlers(“string data”, $(“#someButton”)); // 对 #someButton 进行点击操作之后 // 输出 undefined // 但预期是输出 string data 很显然 this.onButtonClick 作为一个参数传入 on() 之后，事件触发时，是对这个函数进行的直接调用，而不是方法调用，所以其中的 this 会指向全局对象。要解决这个问题有很多种方法 // 这是在 es5 中的解决办法之一 var _this = this; $button.on(“click”, function() { _this.onButtonClick(); }); // 也可以通过 bind() 来解决 $button.on(“click”, this.onButtonClick.bind(this)); // es6 中可以通过箭头函数来处理，在 jQuery 中慎用 $button.on(“click”, e =&gt; this.onButtonClick(e)); 不过请注意，将箭头函数用作 jQuery 的回调时造成要小心函数内对 this 的使用。jQuery 大多数回调函数(非箭头函数)中的 this 都是表示调用目标，所以可以写 $(this).text() 这样的语句，但 jQuery 无法改变箭头函数的 this 指向，同样的语句语义完全不同。 new 调用 在 es6 之前，每一个函数都可以当作是构造函数，通过 new 调用来产生新的对象(函数内无特定返回值的情况下)。而 es6 改变了这种状态，虽然 class 定义的类用 typeof 运算符得到的仍然是 “function”，但它不能像普通函数一样直接调用；同时，class 中定义的方法函数，也不能当作构造函数用 new 来调用。 而在 es5 中，用 new 调用一个构造函数，会创建一个新对象，而其中的 this 就指向这个新对象。这没有什么悬念，因为 new 本身就是设计来创建新对象的。 var data = “Hi”; // 全局变量 function AClass(data) { this.data = data; } var a = new AClass(“Hello World”); console.log(a.data); // Hello World console.log(data); // Hi var b = new AClass(“Hello World”); console.log(a === b); // false 箭头函数中的 this 先来看看 MDN 上对箭头函数的说明 An arrow function expression has a shorter syntax than a function expression and does not bind its own this, arguments,super, or new.target. Arrow functions are always anonymous. These function expressions are best suited for non-method functions, and they cannot be used as constructors. 这里已经清楚了说明了，箭头函数没有自己的 this 绑定。箭头函数中使用的 this，其实是直接包含它的那个函数或函数表达式中的 this。比如 const obj = { test() { const arrow = () =&gt; { // 这里的 this 是 test() 中的 this， // 由 test() 的调用方式决定 console.log(this === obj); }; arrow(); }, getArrow() { return () =&gt; { // 这里的 this 是 getArrow() 中的 this， // 由 getArrow() 的调用方式决定 console.log(this === obj); }; } }; obj.test(); // true const arrow = obj.getArrow(); arrow(); // true 示例中的两个 this 都是由箭头函数的直接外层函数(方法)决定的，而方法函数中的 this 是由其调用方式决定的。上例的调用方式都是方法调用，所以 this 都指向方法调用的对象，即 obj。 箭头函数让大家在使用闭包的时候不需要太纠结 this，不需要通过像 _this 这样的局部变量来临时引用 this 给闭包函数使用。来看一段 Babel 对箭头函数的转译可能能加深理解： // ES6 const obj = { getArrow() { return () =&gt; { console.log(this === obj); }; } } // ES5，由 Babel 转译 var obj = { getArrow: function getArrow() { var _this = this; return function () { console.log(_this === obj); }; } }; 另外需要注意的是，箭头函数不能用 new 调用，不能 bind() 到某个对象(虽然 bind() 方法调用没问题，但是不会产生预期效果)。不管在什么情况下使用箭头函数，它本身是没有绑定 this 的，它用的是直接外层函数(即包含它的最近的一层函数或函数表达式)绑定的 this。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"闭包","date":"2016-02-08T11:45:20.000Z","path":"2016/02/08/闭包/","text":"什么是闭包？ 简言之，闭包是由函数引用其周边状态（词法环境）绑在一起形成的（封装）组合结构。在 JavaScript 中，闭包在每个函数被创建时形成。 这是基本原理，但为什么我们关心这些？实际上，由于闭包与它的词法环境绑在一起，因此闭包让我们能够从一个函数内部访问其外部函数的作用域。 要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。 内部函数将能够访问到外部函数作用域中的变量，即使外部函数已经执行完毕。 闭包使用的例子 闭包的用途之一是实现对象的私有数据。数据私有是让我们能够面向接口编程而不是面向实现编程的基础。而面向接口编程是一个重要的概念，有助于我们创建更加健壮的软件，因为实现细节比接口约定相对来说更加容易被改变。 “面向接口编程，别面向实现编程。” 设计模式：可复用面向对象软件的要素 在 JavaScript 中，闭包是用来实现数据私有的原生机制。当你使用闭包来实现数据私有时，被封装的变量只能在闭包容器函数作用域中使用。你无法绕过对象被授权的方法在外部访问这些数据。在 JavaScript 中，任何定义在闭包作用域下的公开方法才可以访问这些数据。例如： const getSecret = (secret) =&gt; { return { get: () =&gt; secret }; }; test(‘Closure for object privacy.’, assert =&gt; { const msg = ‘.get() should have access to the closure.’; const expected = 1; const obj = getSecret(1); const actual = obj.get(); try { assert.ok(secret, &apos;This throws an error.&apos;); } catch (e) { assert.ok(true, `The secret var is only available to privileged methods.`); } assert.equal(actual, expected, msg); assert.end(); }); 在上面的例子里，get() 方法定义在 getSecret() 作用域下，这让它可以访问任何 getSecret() 中的变量，于是它就是一个被授权的方法。在这个例子里，它可以访问参数 secret。 对象不是唯一的产生私有数据的方式。闭包还可以被用来创建有状态的函数，这些函数的执行过程可能由它们自身的内部状态所决定。例如： const secret = (msg) =&gt; () =&gt; msg; // Secret - creates closures with secret messages. // https://gist.github.com/ericelliott/f6a87bc41de31562d0f9 // https://jsbin.com/hitusu/edit?html,js,output // secret(msg: String) =&gt; getSecret() =&gt; msg: String const secret = (msg) =&gt; () =&gt; msg; test(‘secret’, assert =&gt; { const msg = ‘secret() should return a function that returns the passed secret.’; const theSecret = ‘Closures are easy.’; const mySecret = secret(theSecret); const actual = mySecret(); const expected = theSecret; assert.equal(actual, expected, msg); assert.end(); }); 在函数式编程中，闭包经常用于偏函数应用和柯里化。为了说明这个，我们先定义一些概念： 函数应用：一个过程，指将参数传给一个函数，并获得它的返回值。 偏函数应用：一个过程，它传给某个函数其中一部分参数，然后返回一个新的函数，该函数等待接受后续参数。换句话说，偏函数应用是一个函数，它接受另一个函数为参数，这个作为参数的函数本身接受多个参数，它返回一个函数，这个函数与它的参数函数相比，接受更少的参数。偏函数应用提前赋予一部分参数，而返回的函数则等待调用时传入剩余的参数。 偏函数应用通过闭包作用域来提前赋予参数。你可以实现一个通用的函数来赋予指定的函数部分参数，它看起来如下： partialApply(targetFunction: Function, …fixedArgs: Any[]) =&gt; functionWithFewerParams(…remainingArgs: Any[]) 如果你要更进一步理解上面的形式，你可以看这里（https://github.com/ericelliott/rtype#reading-function-signatures）。 partialApply 接受一个多参数的函数，以及一串我们想要提前赋给这个函数的参数，它返回一个新的函数，这个函数将接受剩余的参数。 下面给一个例子来说明，假设你有一个函数，求两个数的和： const add = (a, b) =&gt; a + b; 现在你想要得到一个函数，它能够对任何传给它的参数都加 10，我们可以将它命名为add10()。add10(5) 的结果应该是 15。我们的 partialApply() 函数可以做到这个： const add10 = partialApply(add, 10); add10(5); 在这个例子里，参数 10 通过闭包作用域被提前赋予 add()，从而让我们获得 add10()。 现在让我们看一下如何实现 partialApply()： // Generic Partial Application Function // https://jsbin.com/biyupu/edit?html,js,output // https://gist.github.com/ericelliott/f0a8fd662111ea2f569e // partialApply(targetFunction: Function, …fixedArgs: Any[]) =&gt; // functionWithFewerParams(…remainingArgs: Any[]) const partialApply = (fn, …fixedArgs) =&gt; { return function (…remainingArgs) { return fn.apply(this, fixedArgs.concat(remainingArgs)); }; }; test(‘add10’, assert =&gt; { const msg = ‘partialApply() should partially apply functions’ const add = (a, b) =&gt; a + b; const add10 = partialApply(add, 10); const actual = add10(5); const expected = 15; assert.equal(actual, expected, msg); }); 如你所见，它只是简单地返回一个函数，这个函数通过闭包访问了传给 partialApply() 函数的fixedArgs 参数。 说了半天，究竟什么是闭包呢？ 闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。 闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。 当在一个函数内定义另外一个函数就会产生闭包。 为了便于理解，我们可以简单的将闭包理解为： 闭包：是指有权访问另外一个函数作用域中的变量的函数。 JavaScript中的作用域 JavaScript中是没有块级作用域的。不过关于块级作用域我们在这里不做深入探究，笔者在JavaScript的作用域和块级作用域概念理解中有对块级作用域较为详细的解释，不懂的读者可以去看看。 变量的作用域无非就是两种：全局变量和局部变量。 Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 var n=999; function f1(){ alert(n); } f1(); // 999 如上函数，f1可调用全局变量n 另一方面，在函数外部自然无法读取函数内的局部变量。 function f1(){ var n=999; } alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量。 function f1(){ n=999; } f1(); alert(n); // 999 闭包 1.理解闭包 我们已经理解了什么是作用域，什么是块级作用域，那又该如何去访问函数内部的变量呢？ 出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。 function f1(){ var n=999; function f2(){ alert(n); } return f2; } var result=f1(); result();// 弹出999 上面函数中的f2函数就是闭包，就是通过建立函数来访问函数内部的局部变量。 2.闭包的用途 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 function f1(){ var n=999; nAdd=function(){n+=1} function f2(){ alert(n); } return f2; } var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 3.闭包的注意点 1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 4.经典闭包小案例 如果你能理解下面全部的案例，那你的闭包就算是真正掌握了。 var name = “The Window”; var object = { name : “My Object”, getNameFunc : function(){ return function(){ return this.name; }; } }; alert(object.getNameFunc()());//The Window var name = “The Window”; var object = { name : “My Object”, getNameFunc : function(){ var that = this; return function(){ return that.name; }; } }; alert(object.getNameFunc()());//My Object function fun(n,o) { console.log(o) return { fun:function(m){ return fun(m,n); } }; } var a = fun(0); a.fun(1); a.fun(2); a.fun(3);//undefined,?,?,? var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,? var c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined,?,?,? //问:三行a,b,c的输出分别是什么？ 这是一道非常典型的JS闭包问题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。 //答案： //a: undefined,0,0,0 //b: undefined,0,1,2 //c: undefined,0,1,1","tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}]},{"title":"从输入 URL 到页面加载完成的过程中都发生了什么事情？","date":"2015-11-27T14:08:39.000Z","path":"2015/11/27/从输入 URL 到页面加载完成的过程中都发生了什么事情？/","text":"作者：百度FEX/吴多益（@吴多益） fex.baidu.com/blog/2014/05/what-happen/ 背景 本文来自于之前我发的一篇微博： 不过写这篇文章并不是为了帮大家准备面试，而是想借这道题来介绍计算机和互联网的基础知识，让读者了解它们之间是如何关联起来的。 为了便于理解，我将整个过程分为了六个问题来展开。 第一个问题：从输入 URL 到浏览器接收的过程中发生了什么事情？ 从触屏到 CPU 首先是「输入 URL」，大部分人的第一反应会是键盘，不过为了与时俱进，这里将介绍触摸屏设备的交互。 触摸屏一种传感器，目前大多是基于电容(Capacitive)来实现的，以前都是直接覆盖在显示屏上的，不过最近出现了 3 种嵌入到显示屏中的技术，第一种是 iPhone 5 的 In-cell，它能减小了 0.5 毫米的厚度，第二种是三星使用的 On-cell 技术，第三种是国内厂商喜欢用的 OGS 全贴合技术，具体细节可以阅读这篇文章。 当手指在这个传感器上触摸时，有些电子会传递到手上，从而导致该区域的电压变化，触摸屏控制器芯片根据这个变化就能计算出所触摸的位置，然后通过总线接口将信号传到 CPU 的引脚上。 以 Nexus 5 为例，它所使用的触屏控制器是 Synaptics S3350B，总线接口为 I²C，以下是 Synaptics 触摸屏和处理器连接的示例： 左边是处理器，右边是触摸屏控制器，中间的 SDA 和 SCL 连线就是 I²C 总线接口。 CPU 内部的处理 移动设备中的 CPU 并不是一个单独的芯片，而是和 GPU 等芯片集成在一起，被称为 SoC（片上系统）。 前面提到了触屏和 CPU 的连接，这个连接和大部分计算机内部的连接一样，都是通过电气信号来进行通信的，也就是电压高低的变化，如下面的时序图： 在时钟的控制下，这些电流会经过 MOSFET 晶体管，晶体管中包含 N 型半导体和 P 型半导体，通过电压就能控制线路开闭，然后这些 MOSFET 构成了 CMOS，接着再由 CMOS 实现「与」「或」「非」等逻辑电路门，最后由逻辑电路门上就能实现加法、位移等计算，整体如下图所示（来自《计算机体系结构》）： 除了计算，在 CPU 中还需要存储单元来加载和存储数据，这个存储单元一般通过触发器(Flip-flop)来实现，称为寄存器。 以上这些概念都比较抽象，推荐阅读「How to Build an 8-Bit Computer」这篇文章，作者基于晶体管、二极管、电容等原件制作了一个 8 位的计算机，支持简单汇编指令和结果输出，虽然现代 CPU 的实现要比这个复杂得多，但基本原理还是一样的。 另外其实我也是刚开始学习 CPU 芯片的实现，所以就不在这误人子弟了，感兴趣的读者请阅读本节后面推荐的书籍。 从 CPU 到操作系统内核 前面说到触屏控制器将电气信号发送到 CPU 对应的引脚上，接着就会触发 CPU 的中断机制，以 Linux 为例，每个外部设备都有一标识符，称为中断请求(IRQ)号，可以通过 /proc/interrupts 文件来查看系统中所有设备的中断请求号，以下是 Nexus 7 (2013) 的部分结果： shell@flo:/ $ cat /proc/interrupts CPU0 17: 0 GIC dg_timer 294: 1973609 msmgpio elan-ktf3k 314: 679 msmgpio KEY_POWER 因为 Nexus 7 使用了 ELAN 的触屏控制器，所以结果中的 elan-ktf3k 就是触屏的中断请求信息，其中 294 是中断号，1973609 是触发的次数（手指单击时会产生两次中断，但滑动时会产生上百次中断）。 为了简化这里不考虑优先级问题，以 ARMv7 架构的处理器为例，当中断发生时，CPU 会停下当前运行的程序，保存当前执行状态（如 PC 值），进入 IRQ 状态），然后跳转到对应的中断处理程序执行，这个程序一般由第三方内核驱动来实现，比如前面提到的 Nexus 7 的驱动源码在这里 touchscreen/ektf3k.c。 这个驱动程序将读取 I²C 总线中传来的位置数据，然后通过内核的 input_report_abs 等方法记录触屏按下坐标等信息，最后由内核中的input 子模块将这些信息都写进 /dev/input/event0 这个设备文件中，比如下面展示了一次触摸事件所产生的信息： 130|shell@flo:/ $ getevent -lt /dev/input/event0 [ 414624.658986] EV_ABS ABS_MT_TRACKING_ID 0000835c [ 414624.659017] EV_ABS ABS_MT_TOUCH_MAJOR 0000000b [ 414624.659047] EV_ABS ABS_MT_PRESSURE 0000001d [ 414624.659047] EV_ABS ABS_MT_POSITION_X 000003f0 [ 414624.659078] EV_ABS ABS_MT_POSITION_Y 00000588 [ 414624.659078] EV_SYN SYN_REPORT 00000000 [ 414624.699239] EV_ABS ABS_MT_TRACKING_ID ffffffff [ 414624.699270] EV_SYN SYN_REPORT 00000000 从操作系统 GUI 到浏览器 前面提到 Linux 内核已经完成了对硬件的抽象，其它程序只需要通过监听 /dev/input/event0 文件的变化就能知道用户进行了哪些触摸操作，不过如果每个程序都这么做实在太麻烦了，所以在图像操作系统中都会包含 GUI 框架来方便应用程序开发，比如 Linux 下著名的 X。 但 Android 并没有使用 X，而是自己实现了一套 GUI 框架，其中有个 EventHub 的服务会通过 epoll 方式监听 /dev/input/ 目录下的文件，然后将这些信息传递到 Android 的窗口管理服务(WindowManagerService)中，它会根据位置信息来查找相应的 app，然后调用其中的监听函数（如 onTouch 等）。 就这样，我们解答了第一个问题，不过由于时间有限，这里省略了很多细节，想进一步学习的读者推荐阅读以下书籍。 扩展学习 《计算机体系结构》 《计算机体系结构：量化研究方法》 《计算机组成与设计：硬件/软件接口》 《编码》 《CPU自制入门》 《操作系统概念》 《ARMv7-AR 体系结构参考手册》 《Linux内核设计与实现》 《精通Linux设备驱动程序开发》 第二个问题：浏览器如何向网卡发送数据？ 从浏览器到浏览器内核 前面提到操作系统 GUI 将输入事件传递到了浏览器中，在这过程中，浏览器可能会做一些预处理，比如 Chrome 会根据历史统计来预估所输入字符对应的网站，比如输入了「ba」，根据之前的历史发现 90% 的概率会访问「www.baidu.com 」，因此就会在输入回车前就马上开始建立 TCP 链接甚至渲染了，这里面还有很多其它策略，感兴趣的读者推荐阅读 High Performance Networking in Chrome。 接着是输入 URL 后的「回车」，这时浏览器会对 URL 进行检查，首先判断协议，如果是 http 就按照 Web 来处理，另外还会对这个 URL 进行安全检查，然后直接调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法。 在浏览器内核中会先查看缓存，然后设置 UA 等 HTTP 信息，接着调用不同平台下网络请求的方法。 需要注意浏览器和浏览器内核是不同的概念，浏览器指的是 Chrome、Firefox，而浏览器内核则是 Blink、Gecko，浏览器内核只负责渲染，GUI 及网络连接等跨平台工作则是浏览器实现的 HTTP 请求的发送 因为网络的底层实现是和内核相关的，所以这一部分需要针对不同平台进行处理，从应用层角度看主要做两件事情：通过 DNS 查询 IP、通过 Socket 发送数据，接下来就分别介绍这两方面的内容。 DNS 查询 应用程序可以直接调用 Libc 提供的 getaddrinfo() 方法来实现 DNS 查询。 DNS 查询其实是基于 UDP 来实现的，这里我们通过一个具体例子来了解它的查找过程，以下是使用 dig +trace fex.baidu.com 命令得到的结果（省略了一些）： ; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace fex.baidu.com ;; global options: +cmd . 11157 IN NS g.root-servers.net. . 11157 IN NS i.root-servers.net. . 11157 IN NS j.root-servers.net. . 11157 IN NS a.root-servers.net. . 11157 IN NS l.root-servers.net. ;; Received 228 bytes from 8.8.8.8#53(8.8.8.8) in 220 ms com. 172800 IN NS a.gtld-servers.net. com. 172800 IN NS c.gtld-servers.net. com. 172800 IN NS m.gtld-servers.net. com. 172800 IN NS h.gtld-servers.net. com. 172800 IN NS e.gtld-servers.net. ;; Received 503 bytes from 192.36.148.17#53(192.36.148.17) in 185 ms baidu.com. 172800 IN NS dns.baidu.com. baidu.com. 172800 IN NS ns2.baidu.com. baidu.com. 172800 IN NS ns3.baidu.com. baidu.com. 172800 IN NS ns4.baidu.com. baidu.com. 172800 IN NS ns7.baidu.com. ;; Received 201 bytes from 192.48.79.30#53(192.48.79.30) in 1237 ms fex.baidu.com. 7200 IN CNAME fexteam.duapp.com. fexteam.duapp.com. 300 IN CNAME duapp.n.shifen.com. n.shifen.com. 86400 IN NS ns1.n.shifen.com. n.shifen.com. 86400 IN NS ns4.n.shifen.com. n.shifen.com. 86400 IN NS ns2.n.shifen.com. n.shifen.com. 86400 IN NS ns5.n.shifen.com. n.shifen.com. 86400 IN NS ns3.n.shifen.com. ;; Received 258 bytes from 61.135.165.235#53(61.135.165.235) in 2 ms 可以看到这是一个逐步缩小范围的查找过程，首先由本机所设置的 DNS 服务器(8.8.8.8)向 DNS 根节点查询负责 .com 区域的域务器，然后通过其中一个负责 .com 的服务器查询负责 baidu.com 的服务器，最后由其中一个 baidu.com 的域名服务器查询 fex.baidu.com 域名的地址。 可能你在查询某些域名的时会发现和上面不一样，最底将看到有个奇怪的服务器抢先返回结果。。。 这里为了方便描述，忽略了很多不同的情况，比如 127.0.0.1 其实走的是 loopback，和网卡设备没关系；比如 Chrome 会在浏览器启动的时预先查询 10 个你有可能访问的域名；还有 Hosts 文件、缓存时间 TTL(Time to live)的影响等。 通过 Socket 发送数据 有了 IP 地址，就可以通过 Socket API 来发送数据了，这时可以选择 TCP 或 UDP 协议，具体使用方法这里就不介绍了，推荐阅读 Beej’s Guide to Network Programming。 HTTP 常用的是 TCP 协议，由于 TCP 协议的具体细节到处都能看到，所以本文就不介绍了，这里谈一下 TCP 的 Head-of-line blocking 问题：假设客户端的发送了 3 个 TCP 片段(segments)，编号分别是 1、2、3，如果编号为 1 的包传输时丢了，即便编号 2 和 3 已经到达也只能等待，因为 TCP 协议需要保证顺序，这个问题在 HTTP pipelining 下更严重，因为 HTTP pipelining 可以让多个 HTTP 请求通过一个 TCP 发送，比如发送两张图片，可能第二张图片的数据已经全收到了，但还得等第一张图片的数据传到。 为了解决 TCP 协议的性能问题，Chrome 团队去年提出了 QUIC 协议，它是基于 UDP 实现的可靠传输，比起 TCP，它能减少很多来回(round trip)时间，还有前向纠错码(Forward Error Correction)等功能。目前 Google Plus、 Gmail、Google Search、blogspot、Youtube 等几乎大部分 Google 产品都在使用 QUIC，可以通过 chrome://net-internals/#spdy 页面来发现。 虽然目前除了 Google 还没人用 QUIC，但我觉得挺有前景的，因为优化 TCP 需要升级系统内核（比如 Fast Open）。 浏览器对同一个域名有连接数限制，大部分是 6，我以前认为将这个连接数改大后会提升性能，但实际上并不是这样的，Chrome 团队有做过实验，发现从 6 改成 10 后性能反而下降了，造成这个现象的因素有很多，如建立连接的开销、拥塞控制等问题，而像 SPDY、HTTP 2.0 协议尽管只使用一个 TCP 连接来传输数据，但性能反而更好，而且还能实现请求优先级。 另外，因为 HTTP 请求是纯文本格式的，所以在 TCP 的数据段中可以直接分析 HTTP 的文本，如果发现。。。 Socket 在内核中的实现 前面说到浏览器的跨平台库通过调用 Socket API 来发送数据，那么 Socket API 是如何实现的呢？ 以 Linux 为例，它的实现在这里 socket.c，目前我还不太了解，推荐读者看看 Linux kernel map，它标注出了关键路径的函数，方便学习从协议栈到网卡驱动的实现。 底层网络协议的具体例子 接下来如果继续介绍 IP 协议和 MAC 协议可能很多读者会晕，所以本节将使用 Wireshark 来通过具体例子讲解，以下是我请求百度首页时抓取到的网络数据： 最底下是实际的二进制数据，中间是解析出来的各个字段值，可以看到其中最底部为 HTTP 协议(Hypertext Transfer Protocol)，在 HTTP 之前有 54 字节(0×36)，这就是底层网络协议所带来的开销，我们接下来对这些协议进行分析。 在 HTTP 之上是 TCP 协议(Transmission Control Protocol)，它的具体内容如下图所示： 通过底部的二进制数据，可以看到 TCP 协议是加在 HTTP 文本前面的，它有 20 个字节，其中定义了本地端口(Source port)和目标端口(Destination port)、顺序序号(Sequence Number)、窗口长度等信息，以下是 TCP 协议各个部分数据的完整介绍： 具体各个字段的作用这里就不介绍了，感兴趣的读者可以阅读 RFC 793，并结合抓包分析来理解。 需要注意的是，在 TCP 协议中并没有 IP 地址信息，因为这是在上一层的 IP 协议中定义的，如下图所示： IP 协议同样是在 TCP 前面的，它也有 20 字节，在这里指明了版本号(Version)为 4，源(Source) IP 为 192.168.1.106，目标(Destination) IP 为 119.75.217.56，因此 IP 协议最重要的作用就是确定 IP 地址。 因为 IP 协议中可以查看到目标 IP 地址，所以如果发现某些特定的 IP 地址，某些路由器就会。。。 但是，光靠 IP 地址是无法进行通信的，因为 IP 地址并不和某台设备绑定，比如你的笔记本的 IP 在家中是 192.168.1.1，但到公司就变成172.22.22.22 了，所以在底层通信时需要使用一个固定的地址，这就是 MAC(media access control) 地址，每个网卡出厂时的 MAC 地址都是固定且唯一的。 因此再往上就是 MAC 协议，它有 14 字节，如下所示： 当一台电脑加入网络时，需要通过 ARP 协议告诉其它网络设备它的 IP 及对应的 MAC 地址是什么，这样其它设备就能通过 IP 地址来查找对应的设备了。 最顶上的 Frame 是代表 Wireshark 的抓包序号，并不是网络协议 就这样，我们解答了第二个问题，不过其实这里面还有很多很多细节没介绍，建议大家通过下面的书籍进一步学习。 扩展学习 《计算机网络：自顶向下方法与Internet特色》 《计算机网络》 《Web性能权威指南》 第三个问题：数据如何从本机网卡发送到服务器？ 从内核到网络适配器(Network Interface Card) 前面说到调用 Socket API 后内核会对数据进行底层协议栈的封装，接下来启动 DMA 控制器，它将从内存中读取数据写入网卡。 以 Nexus 5 为例，它使用的是博通 BCM4339 芯片通信，接口采用了 SD 卡一样的 SDIO，但这个芯片的细节并没有公开资料，所以这里就不讨论了。 连接 Wi-Fi 路由 Wi-Fi 网卡需要通过 Wi-Fi 路由来与外部通信，原理是基于无线电，通过电流变化来产生无线电，这个过程也叫「调制」，而反过来无线电可以引起电磁场变化，从而产生电流变化，利用这个原理就能将无线电中的信息解读出来就叫「解调」，其中单位时间内变化的次数就称为频率，目前在 Wi-Fi 中所采用的频率分为 2.4 GHz 和 5 GHz 两种。 在同一个 Wi-Fi 路由下，因为采用的频率相同，同时使用时会发生冲突，为了解决这个问题，Wi-Fi 采用了被称为 CSMA/CA 的方法，简单来说就是在传输前先确认信道是否已被使用，没有才发送数据。 而同样基于无线电原理的 2G/3G/LTE 也会遇到类似的问题，但它并没有采用 Wi-Fi 那样的独占方案，而是通过频分(FDMA)、时分(TDMA)和码分(CDMA)来进行复用，具体细节这里就不展开了。 以小米路由为例，它使用的芯片是 BCM 4709，这个芯片由 ARM Cortex-A9 处理器及流量(Flow)硬件加速组成，使用硬件芯片可以避免经过操作系统中断、上下文切换等操作，从而提升了性能。 路由器中的操作系统可以基于 OpenWrt 或 DD-WRT 来开发的，具体细节我不太了解，所以就不展开了。 因为内网设备的 IP 都是类似 192.168.1.x 这样的内网地址，外网无法直接向这个地址发送数据，所以网络数据在经过路由时，路由会修改相关地址和端口，这个操作称为 NAT 映射。 最后家庭路由一般会通过双绞线连接到运营商网络的。 运营商网络内的路由 数据过双绞线发送到运营商网络后，还会经过很多个中间路由转发，读者可以通过 traceroute 命令或者在线可视化工具来查看这些路由的 ip 和位置。 当数据传递到这些路由器后，路由器会取出包中目的地址的前缀，通过内部的转发表查找对应的输出链路，而这个转发表是如何得到的呢？这就是路由器中最重要的选路算法了，可选的有很多，我对这方面并不太了解，看起来维基百科上的词条列得很全。 主干网间的传输 对于长线的数据传输，通常使用光纤作为介质，光纤是基于光的全反射来实现的，使用光纤需要专门的发射器通过电致发光（比如 LED）将电信号转成光，比起前面介绍的无线电和双绞线，光纤信号的抗干扰性要强得多，而且能耗也小很多。 既然是基于光来传输数据，数据传输速度也就取决于光的速度，在真空中的光速接近于 30 万千米/秒，由于光纤包层(cladding)中的折射率(refractive index)为 1.52，所以实际光速是 20 万千米/秒左右，从首都机场飞往广州白云机场的距离是 1967 千米，按照这个距离来算需要花费 10 毫秒才能抵达。这意味着如果你在北京，服务器在广州，等你发出数据到服务器返回数据至少得等 20 毫秒，实际情况预计是 2- 3 倍，因为这其中还有各个节点路由处理的耗时，比如我测试了一个广州的 IP 发现平均延迟为 60 毫秒。 这个延迟是现有科技无法解决的（除非找到超过光速的方法），只能通过 CDN 来让传输距离变短，或尽量减少串行的来回请求（比如 TCP 建立连接所需的 3 次握手）。 IDC 内网 数据通过光纤最终会来到服务器所在的 IDC 机房，进入 IDC 内网，这时可以先通过分光器将流量镜像一份出来方便进行安全检查等分析，还能用来进行。。。 这里的带宽成本很高，是按照峰值来结算的，以每月每 Gbps（注意这里指的是 bit，而不是 Byte）为单位，北京这边价格在十万人民币以上，一般网站使用 1G 到 10G 不等。 接下来光纤中的数据将进入集群(Cluster)交换机，然后再转发到机架(Rack)顶部的交换机，最后通过这个交换机的端口将数据发往机架中的服务器，可以参考下图（来自 Open Compute）： 上图左边是正面，右边是侧面，可以看到顶部为交换机所留的位置。 以前这些交换机的内部实现是封闭的，相关厂商（如思科、Juniper 等）会使用特定的处理器和操作系统，外界难以进行灵活控制，甚至有时候需要手工配置，但这几年随着 OpenFlow 技术的流行，也出现了开放交换机硬件(Open Switch Hardware)，比如 Intel 的网络平台，推荐感兴趣的读者建议看看它的视频，比文字描述清晰多了。 需要注意的是，一般网络书中提到的交换机都只具备二层（MAC 协议）的功能，但在 IDC 中的交换器基本上都具备三层（IP 协议）的功能，所以不需要有专门的路由了。 最后，因为 CPU 处理的是电气信号，所以光纤中的光线需要先使用相关设备通过光电效应将光信号转成电信号，然后进入服务器网卡。 服务器 CPU 前面说到数据已经到达服务器网卡了，接着网卡会将数据拷贝到内存中（DMA），然后通过中断来通知 CPU，目前服务器端的 CPU 基本上都是 Intel Xeon，不过这几年出现了一些新的架构，比如在存储领域，百度使用 ARM 架构来提升存储密度，因为 ARM 的功耗比 Xeon 低得多。而在高性能领域，Google 最近在尝试基于 POWER 架构的 CPU 来开发的服务器，最新的 POWER8 处理器可以并行执行 96 个线程，所以对高并发的应用应该很有帮助。 扩展学习 The Datacenter as a Computer Open Computer 《软件定义网络》 《大话无线通信》 第四个问题：服务器接收到数据后会进行哪些处理？ 为了避免重复，这里将不再介绍操作系统，而是直接进入后端服务进程，由于这方面有太多技术选型，所以我只挑几个常见的公共部分来介绍。 负载均衡 请求在进入到真正的应用服务器前，可能还会先经过负责负载均衡的机器，它的作用是将请求合理地分配到多个服务器上，同时具备具备防攻击等功能。 负载均衡具体实现有很多种，有直接基于硬件的 F5，有操作系统传输层(TCP)上的 LVS，也有在应用层(HTTP)实现的反向代理（也叫七层代理），接下来将介绍 LVS 及反向代理。 负载均衡的策略也有很多，如果后面的多个服务器性能均衡，最简单的方法就是挨个循环一遍(Round-Robin)，其它策略就不一一介绍了，可以参考 LVS 中的算法。 LVS LVS 的作用是从对外看来只有一个 IP，而实际上这个 IP 后面对应是多台机器，因此也被成为 Virtual IP。 前面提到的 NAT 也是一种 LVS 中的工作模式，除此之外还有 DR 和 TUNNEL，具体细节这里就不展开了，它们的缺点是无法跨网段，所以百度自己开发了 BVS 系统。 反向代理 方向代理是工作在 HTTP 上的，具体实现可以基于 HAProxy 或 Nginx，因为反向代理能理解 HTTP 协议，所以能做非常多的事情，比如： 进行很多统一处理，比如防攻击策略、放抓取、SSL、gzip、自动性能优化等 应用层的分流策略都能在这里做，比如对 /xx 路径的请求分到 a 服务器，对 /yy 路径的请求分到 b 服务器，或者按照 cookie 进行小流量测试等 缓存，并在后端服务挂掉的时候显示友好的 404 页面 监控后端服务是否异常 ⋯⋯ Nginx 的代码写得非常优秀，从中能学到很多，对高性能服务端开发感兴趣的读者一定要看看。 Web Server 中的处理 请求经过前面的负载均衡后，将进入到对应服务器上的 Web Server，比如 Apache、Tomcat、Node.JS 等。 以 Apache 为例，在接收到请求后会交给一个独立的进程来处理，我们可以通过编写 Apache 扩展来处理，但这样开发起来太麻烦了，所以一般会调用 PHP 等脚本语言来进行处理，比如在 CGI 下就是将 HTTP 中的参数放到环境变量中，然后启动 PHP 进程来执行，或者使用 FastCGI 来预先启动进程。 （等后续有空再单独介绍 Node.JS 中的处理） 进入后端语言 前面说到 Web Server 会调用后端语言进程来处理 HTTP 请求（这个说法不完全正确，有很多其它可能），那么接下来就是后端语言的处理了，目前大部分后端语言都是基于虚拟机的，如 PHP、Java、JavaScript、Python 等，但这个领域的话题非常大，难以讲清楚，对 PHP 感兴趣的读者可以阅读我之前写的 HHVM 介绍文章，其中提到了很多虚拟机的基础知识。 Web 框架(Framework) 如果你的 PHP 只是用来做简单的个人主页「Personal Home Page」，倒没必要使用 Web 框架，但如果随着代码的增加会变得越来越难以管理，所以一般网站都会会基于某个 Web 框架来开发，因此在后端语言执行时首先进入 Web 框架的代码，然后由框架再去调用应用的实现代码。 可选的 Web 框架非常多，这里就不一一介绍了。 读取数据 这部分不展开了，从简单的读写文件到数据中间层，这里面可选的方案实在太多。 扩展学习 《深入理解Nginx》 《Python源码剖析》 《深入理解Java虚拟机》 《数据库系统实现》 第五个问题：服务器返回数据后浏览器如何处理？ 前面说到服务端处理完请求后，结果将通过网络发回客户端的浏览器，从本节开始将介绍浏览器接收到数据后的处理，值得一提的是这方面之前有一篇不错的文章 How Browsers Work，所以很多内容我不想再重复介绍，因此将重点放在那篇文章所忽略的部分。 从 01 到字符 HTTP 请求返回的 HTML 传递到浏览器后，如果有 gzip 会先解压，然后接下来最重要的问题是要知道它的编码是什么，比如同样一个「中」字，在 UTF-8 编码下它的内容其实是「11100100 10111000 10101101」也就是「E4 B8 AD」，而在 GBK 下则是「11010110 11010000」，也就是「D6 D0」，如何才能知道文件的编码？可以有很多判断方法： 用户设置，在浏览器中可以指定页面编码 HTTP 协议中 中的 charset 属性值 对于 JS 和 CSS 对于 iframe 如果在这些地方都没指明，浏览器就很难处理，在它看来就是一堆「0」和「1」，比如「中文」，它在 UTF-8 下有 6 个字节，如果按照 GBK 可以当成「涓枃」这 3 个汉字来解释，浏览器怎么知道到底是「中文」还是「涓枃」呢？ 不过正常人一眼就能认出「涓枃」是错的，因为这 3 个字太不常见了，所以有人就想到通过判断常见字的方法来检测编码，典型的比如 Mozilla 的 UniversalCharsetDetection，不过这东东误判率也很高，所以还是指明编码的好。 这样后续对文本的操作就是基于「字符」(Character)的了，一个汉字就是一个字符，不用再关心它究竟是 2 个字节还是 3 个字节。 外链资源的加载 （待补充，这里有调度策略） JavaScript 的执行 （后续再单独介绍，推荐大家看 R 大去年整理的这个帖子，里面有非常多相关资料，另外我两年前曾讲过 JavaScript 引擎中的性能优化，虽然有些内容不太正确了，但也可以看看） 从字符到图片 二维渲染中最复杂的要数文字显示了，虽然想想似乎很简单，不就是将某个文字对应的字形(glyph)找出来么？在中文和英文中这样做是没问题的，因为一个字符就对应一个字形(glyph)，在字体文件中找到字形，然后画上去就可以了，但在阿拉伯语中是不行的，因为它有有连体形式。 （以后续再单独介绍，这里非常复杂） 跨平台 2D 绘制库 在不同操作系统中都提供了自己的图形绘制 API，比如 Mac OS X 下的 Quartz，Windows 下的 GDI 以及 Linux 下的 Xlib，但它们相互不兼容，所以为了方便支持跨平台绘图，在 Chrome 中使用了 Skia 库。 （以后再单独介绍，Skia 内部实现调用层级太多，直接讲代码可能不适合初学者） GPU 合成 （以后续再单独介绍，虽然简单来说就是靠贴图，但还得介绍 OpenGL 以及 GPU 芯片，内容太长） 扩展学习 这节内容是我最熟悉，结果反而因为这样才想花更多时间写好，所以等到以后再发出来好了，大家先可以先看看以下几个站点： Chromium Mozilla Hacks Surfin’ Safari 第六个问题：浏览器如何将页面展现出来？ 前面提到浏览器已经将页面渲染成一张图片了，接下来的问题就是如何将这张图片展示在屏幕上。 Framebuffer 以 Linux 为例，在应用中控制屏幕最直接的方法是将图像的 bitmap 写入 /dev/fb0 文件中，这个文件实际上一个内存区域的映射，这段内存区域称为 Framebuffer。 需要注意的是在硬件加速下，如 OpenGL 是不经过 Framebuffer 的。 从内存到 LCD 在手机的 SoC 中通常都会有一个 LCD 控制器，当 Framebuffer 准备好后，CPU 会通过 AMBA 内部总线通知 LCD 控制器，然后这个控制器读取 Framebuffer 中的数据，进行格式转换、伽马校正等操作，最终通过 DSI、HDMI 等接口发往 LCD 显示器。 以 OMAP5432 为例，下图是它所支持的一种并行数据传输： LCD 显示 最后简单介绍一下 LCD 的显示原理。 首先，要想让人眼能看见，就必须有光线进入，要么通过反射、要么有光源，比如 Kindle 所使用的 E-ink 屏幕本身是不发光的，所以必须在有光线的地方才能阅读，它的优点是省电，但限制太大，所以几乎所有 LCD 都会自带光源。 目前 LCD 中通常使用 LED 作为光源，LED 接上电源后，在电压的作用下，内部的正负电子结合会释放光子，从而产生光，这种物理现象叫电致发光(Electroluminescence)，这在前面介绍光纤时也介绍过。 以下是 iPod Touch 2 拆开后的样子：（来自 Wikipedia）： 在上图中可以看到 6 盏 LED，这就是整个屏幕的光源，这些光源将通过反射的反射输出到屏幕中。 有了光源还得有色彩，在 LED 中通常做法是使用彩色滤光片(Color filter)来将 LED 光源转成不同颜色。 另外直接使用三种颜色的 LED 也是可行的，它能避免了滤光导致的光子浪费，降低耗电，很适用于智能手表这样的小屏幕，Apple 收购的 LuxVue 公司就采用的是这种方式，感兴趣的话可以去研究它的专利 LCD 屏幕上的每个物理像素点实际上是由红、绿、蓝 3 种色彩的点组成，每个颜色点能单独控制，下面是用显微镜放大后的情况（来自Wikipedia）： 从上图可以看到每 3 种颜色的滤光片都全亮的时候就是白色，都灭就是黑色，如果你仔细看还能看到有些点并不是完全黑，这是字体上的反锯齿效果。 通过这 3 种颜色亮度的不同组合就能产生出各种色彩，如果每个颜色点能产生 256 种亮度，就能生成 256 256 256 = 16777216 种色彩。 并不是所有显示器的亮度都能达到 256，在选择显示器时有个参数是 8-Bit 或 6-Bit 面板，其中 8-Bit 的面板能在物理上达到 256 种亮度，而 6-Bit 的则只有 64 种，它需要靠刷新率控制(Frame rate control)技术来达到 256 的效果。 如何控制这些颜色点的亮度？这就要靠液晶体了，液晶体的特性是当有电流通过时会发生旋转，从而将部分光线挡住，所以只要通过电压控制液晶体的转动就能控制这个颜色点的亮度，目前手机屏幕中通常使用 TFT 控制器来对其进行控制，在 TFT 中最著名的要数 IPS 面板。 这些过滤后的光线大部分会直接进入眼睛，有些光还会在其它表面上经过漫(diffuse)反射或镜面(specular)反射后再进入眼睛，加上环境光的影响，要真正算出有多少光到眼睛是一个积分问题，感兴趣的读者可以研究基于物理的渲染。 当光线进入眼睛后，接下来就是生物学的领域了，所以我们到此结束。 扩展学习 《Computer Graphics, 3rd Edition : Principles and Practices》 《交互式计算机图形学》 本文所忽略的内容 为了编写方便，前面的介绍中将很多底层细节实现忽略了，比如： 内存相关 堆，这里的分配策略有很多，比如 malloc 的实现 栈，函数调用，已经有很多优秀的文章或书籍介绍了 内存映射，动态库加载等 队列几乎无处不在，但这些细节和原理没太大关系 各种缓存 CPU 的缓存、操作系统的缓存、HTTP 缓存、后端缓存等等 各种监控 很多日志会保存下来以便后续分析","tags":[{"name":"URL","slug":"URL","permalink":"http://yoursite.com/tags/URL/"}]}]